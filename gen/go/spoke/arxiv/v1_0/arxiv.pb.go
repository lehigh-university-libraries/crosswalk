// arXiv metadata record format.
// Source: arXiv metadata schema 1.0
// Spec: https://arxiv.org/help/prep (based on fixtures/arxiv/1.0.xsd)

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        (unknown)
// source: spoke/arxiv/v1_0/arxiv.proto

package v1_0

import (
	_ "github.com/lehigh-university-libraries/crosswalk/gen/go/hub/v1"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// SourceType enumerates source file types.
type SourceType int32

const (
	SourceType_SOURCE_TYPE_UNSPECIFIED   SourceType = 0
	SourceType_SOURCE_TYPE_TEX           SourceType = 1
	SourceType_SOURCE_TYPE_ENCRYPTED_TEX SourceType = 2
	SourceType_SOURCE_TYPE_PS            SourceType = 3
	SourceType_SOURCE_TYPE_PDF           SourceType = 4
	SourceType_SOURCE_TYPE_HTML          SourceType = 5
	SourceType_SOURCE_TYPE_IGNORE        SourceType = 6
)

// Enum value maps for SourceType.
var (
	SourceType_name = map[int32]string{
		0: "SOURCE_TYPE_UNSPECIFIED",
		1: "SOURCE_TYPE_TEX",
		2: "SOURCE_TYPE_ENCRYPTED_TEX",
		3: "SOURCE_TYPE_PS",
		4: "SOURCE_TYPE_PDF",
		5: "SOURCE_TYPE_HTML",
		6: "SOURCE_TYPE_IGNORE",
	}
	SourceType_value = map[string]int32{
		"SOURCE_TYPE_UNSPECIFIED":   0,
		"SOURCE_TYPE_TEX":           1,
		"SOURCE_TYPE_ENCRYPTED_TEX": 2,
		"SOURCE_TYPE_PS":            3,
		"SOURCE_TYPE_PDF":           4,
		"SOURCE_TYPE_HTML":          5,
		"SOURCE_TYPE_IGNORE":        6,
	}
)

func (x SourceType) Enum() *SourceType {
	p := new(SourceType)
	*p = x
	return p
}

func (x SourceType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SourceType) Descriptor() protoreflect.EnumDescriptor {
	return file_spoke_arxiv_v1_0_arxiv_proto_enumTypes[0].Descriptor()
}

func (SourceType) Type() protoreflect.EnumType {
	return &file_spoke_arxiv_v1_0_arxiv_proto_enumTypes[0]
}

func (x SourceType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SourceType.Descriptor instead.
func (SourceType) EnumDescriptor() ([]byte, []int) {
	return file_spoke_arxiv_v1_0_arxiv_proto_rawDescGZIP(), []int{0}
}

// ClassificationScheme enumerates supported classification schemes.
type ClassificationScheme int32

const (
	ClassificationScheme_CLASSIFICATION_SCHEME_UNSPECIFIED ClassificationScheme = 0
	ClassificationScheme_CLASSIFICATION_SCHEME_MSC1991     ClassificationScheme = 1
	ClassificationScheme_CLASSIFICATION_SCHEME_MSC2000     ClassificationScheme = 2
	ClassificationScheme_CLASSIFICATION_SCHEME_ACM1998     ClassificationScheme = 3
	ClassificationScheme_CLASSIFICATION_SCHEME_PACS2003    ClassificationScheme = 4
)

// Enum value maps for ClassificationScheme.
var (
	ClassificationScheme_name = map[int32]string{
		0: "CLASSIFICATION_SCHEME_UNSPECIFIED",
		1: "CLASSIFICATION_SCHEME_MSC1991",
		2: "CLASSIFICATION_SCHEME_MSC2000",
		3: "CLASSIFICATION_SCHEME_ACM1998",
		4: "CLASSIFICATION_SCHEME_PACS2003",
	}
	ClassificationScheme_value = map[string]int32{
		"CLASSIFICATION_SCHEME_UNSPECIFIED": 0,
		"CLASSIFICATION_SCHEME_MSC1991":     1,
		"CLASSIFICATION_SCHEME_MSC2000":     2,
		"CLASSIFICATION_SCHEME_ACM1998":     3,
		"CLASSIFICATION_SCHEME_PACS2003":    4,
	}
)

func (x ClassificationScheme) Enum() *ClassificationScheme {
	p := new(ClassificationScheme)
	*p = x
	return p
}

func (x ClassificationScheme) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ClassificationScheme) Descriptor() protoreflect.EnumDescriptor {
	return file_spoke_arxiv_v1_0_arxiv_proto_enumTypes[1].Descriptor()
}

func (ClassificationScheme) Type() protoreflect.EnumType {
	return &file_spoke_arxiv_v1_0_arxiv_proto_enumTypes[1]
}

func (x ClassificationScheme) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ClassificationScheme.Descriptor instead.
func (ClassificationScheme) EnumDescriptor() ([]byte, []int) {
	return file_spoke_arxiv_v1_0_arxiv_proto_rawDescGZIP(), []int{1}
}

// Record represents an arXiv metadata record for a paper version.
type Record struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Paper identifier in canonical form (e.g., hep-th/9901001, math.AG/0101001)
	Identifier string `protobuf:"bytes,1,opt,name=identifier,proto3" json:"identifier,omitempty"`
	// Primary classification (e.g., hep-th, math.AG, cond-mat.supr-con)
	Primary string `protobuf:"bytes,2,opt,name=primary,proto3" json:"primary,omitempty"`
	// Cross-listed classifications
	Cross []string `protobuf:"bytes,3,rep,name=cross,proto3" json:"cross,omitempty"`
	// Submitter information
	Submitter *Submitter `protobuf:"bytes,4,opt,name=submitter,proto3" json:"submitter,omitempty"`
	// Proxy submitter (optional)
	Proxy *Proxy `protobuf:"bytes,5,opt,name=proxy,proto3" json:"proxy,omitempty"`
	// Version number
	Version int32 `protobuf:"varint,6,opt,name=version,proto3" json:"version,omitempty"`
	// Submission date (ISO 8601 with Z suffix)
	Date string `protobuf:"bytes,7,opt,name=date,proto3" json:"date,omitempty"`
	// Source file information
	Source *Source `protobuf:"bytes,8,opt,name=source,proto3" json:"source,omitempty"`
	// Version history
	History []*History `protobuf:"bytes,9,rep,name=history,proto3" json:"history,omitempty"`
	// Title (may contain TeX markup)
	Title string `protobuf:"bytes,10,opt,name=title,proto3" json:"title,omitempty"`
	// Authorship information (authors and affiliations)
	Authorship *Authorship `protobuf:"bytes,11,opt,name=authorship,proto3" json:"authorship,omitempty"`
	// External classifications (MSC, ACM, PACS)
	Classification []*Classification `protobuf:"bytes,12,rep,name=classification,proto3" json:"classification,omitempty"`
	// Alternate identifiers (report numbers, journal refs, DOIs)
	Alternate *Alternate `protobuf:"bytes,13,opt,name=alternate,proto3" json:"alternate,omitempty"`
	// Comments (may contain TeX markup)
	Comments []string `protobuf:"bytes,14,rep,name=comments,proto3" json:"comments,omitempty"`
	// Abstract (may contain TeX markup)
	Abstract []string `protobuf:"bytes,15,rep,name=abstract,proto3" json:"abstract,omitempty"`
	// Attic - old metadata storage for migrations
	Attic         []*Attic `protobuf:"bytes,16,rep,name=attic,proto3" json:"attic,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Record) Reset() {
	*x = Record{}
	mi := &file_spoke_arxiv_v1_0_arxiv_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Record) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Record) ProtoMessage() {}

func (x *Record) ProtoReflect() protoreflect.Message {
	mi := &file_spoke_arxiv_v1_0_arxiv_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Record.ProtoReflect.Descriptor instead.
func (*Record) Descriptor() ([]byte, []int) {
	return file_spoke_arxiv_v1_0_arxiv_proto_rawDescGZIP(), []int{0}
}

func (x *Record) GetIdentifier() string {
	if x != nil {
		return x.Identifier
	}
	return ""
}

func (x *Record) GetPrimary() string {
	if x != nil {
		return x.Primary
	}
	return ""
}

func (x *Record) GetCross() []string {
	if x != nil {
		return x.Cross
	}
	return nil
}

func (x *Record) GetSubmitter() *Submitter {
	if x != nil {
		return x.Submitter
	}
	return nil
}

func (x *Record) GetProxy() *Proxy {
	if x != nil {
		return x.Proxy
	}
	return nil
}

func (x *Record) GetVersion() int32 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *Record) GetDate() string {
	if x != nil {
		return x.Date
	}
	return ""
}

func (x *Record) GetSource() *Source {
	if x != nil {
		return x.Source
	}
	return nil
}

func (x *Record) GetHistory() []*History {
	if x != nil {
		return x.History
	}
	return nil
}

func (x *Record) GetTitle() string {
	if x != nil {
		return x.Title
	}
	return ""
}

func (x *Record) GetAuthorship() *Authorship {
	if x != nil {
		return x.Authorship
	}
	return nil
}

func (x *Record) GetClassification() []*Classification {
	if x != nil {
		return x.Classification
	}
	return nil
}

func (x *Record) GetAlternate() *Alternate {
	if x != nil {
		return x.Alternate
	}
	return nil
}

func (x *Record) GetComments() []string {
	if x != nil {
		return x.Comments
	}
	return nil
}

func (x *Record) GetAbstract() []string {
	if x != nil {
		return x.Abstract
	}
	return nil
}

func (x *Record) GetAttic() []*Attic {
	if x != nil {
		return x.Attic
	}
	return nil
}

// Submitter represents submitter information.
type Submitter struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Email address
	Email string `protobuf:"bytes,1,opt,name=email,proto3" json:"email,omitempty"`
	// User ID in authentication system
	Identifier    string `protobuf:"bytes,2,opt,name=identifier,proto3" json:"identifier,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Submitter) Reset() {
	*x = Submitter{}
	mi := &file_spoke_arxiv_v1_0_arxiv_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Submitter) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Submitter) ProtoMessage() {}

func (x *Submitter) ProtoReflect() protoreflect.Message {
	mi := &file_spoke_arxiv_v1_0_arxiv_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Submitter.ProtoReflect.Descriptor instead.
func (*Submitter) Descriptor() ([]byte, []int) {
	return file_spoke_arxiv_v1_0_arxiv_proto_rawDescGZIP(), []int{1}
}

func (x *Submitter) GetEmail() string {
	if x != nil {
		return x.Email
	}
	return ""
}

func (x *Submitter) GetIdentifier() string {
	if x != nil {
		return x.Identifier
	}
	return ""
}

// Proxy represents a proxy submitter.
type Proxy struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// User ID of proxy submitter
	Identifier string `protobuf:"bytes,1,opt,name=identifier,proto3" json:"identifier,omitempty"`
	// Remote identifier in proxy's database
	RemoteIdentifier string `protobuf:"bytes,2,opt,name=remote_identifier,json=remoteIdentifier,proto3" json:"remote_identifier,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *Proxy) Reset() {
	*x = Proxy{}
	mi := &file_spoke_arxiv_v1_0_arxiv_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Proxy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Proxy) ProtoMessage() {}

func (x *Proxy) ProtoReflect() protoreflect.Message {
	mi := &file_spoke_arxiv_v1_0_arxiv_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Proxy.ProtoReflect.Descriptor instead.
func (*Proxy) Descriptor() ([]byte, []int) {
	return file_spoke_arxiv_v1_0_arxiv_proto_rawDescGZIP(), []int{2}
}

func (x *Proxy) GetIdentifier() string {
	if x != nil {
		return x.Identifier
	}
	return ""
}

func (x *Proxy) GetRemoteIdentifier() string {
	if x != nil {
		return x.RemoteIdentifier
	}
	return ""
}

// Source describes the source file for the submission.
type Source struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Source type (tex, encrypted-tex, ps, pdf, html, ignore)
	Type SourceType `protobuf:"varint,1,opt,name=type,proto3,enum=spoke.arxiv.v1_0.SourceType" json:"type,omitempty"`
	// File size in bytes
	Size int64 `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`
	// MD5 checksum (32 hex characters)
	Md5           string `protobuf:"bytes,3,opt,name=md5,proto3" json:"md5,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Source) Reset() {
	*x = Source{}
	mi := &file_spoke_arxiv_v1_0_arxiv_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Source) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Source) ProtoMessage() {}

func (x *Source) ProtoReflect() protoreflect.Message {
	mi := &file_spoke_arxiv_v1_0_arxiv_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Source.ProtoReflect.Descriptor instead.
func (*Source) Descriptor() ([]byte, []int) {
	return file_spoke_arxiv_v1_0_arxiv_proto_rawDescGZIP(), []int{3}
}

func (x *Source) GetType() SourceType {
	if x != nil {
		return x.Type
	}
	return SourceType_SOURCE_TYPE_UNSPECIFIED
}

func (x *Source) GetSize() int64 {
	if x != nil {
		return x.Size
	}
	return 0
}

func (x *Source) GetMd5() string {
	if x != nil {
		return x.Md5
	}
	return ""
}

// History records information about a previous version.
type History struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Version number
	Version int32 `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	// Submission date
	Date string `protobuf:"bytes,2,opt,name=date,proto3" json:"date,omitempty"`
	// Source file information
	Source        *Source `protobuf:"bytes,3,opt,name=source,proto3" json:"source,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *History) Reset() {
	*x = History{}
	mi := &file_spoke_arxiv_v1_0_arxiv_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *History) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*History) ProtoMessage() {}

func (x *History) ProtoReflect() protoreflect.Message {
	mi := &file_spoke_arxiv_v1_0_arxiv_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use History.ProtoReflect.Descriptor instead.
func (*History) Descriptor() ([]byte, []int) {
	return file_spoke_arxiv_v1_0_arxiv_proto_rawDescGZIP(), []int{4}
}

func (x *History) GetVersion() int32 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *History) GetDate() string {
	if x != nil {
		return x.Date
	}
	return ""
}

func (x *History) GetSource() *Source {
	if x != nil {
		return x.Source
	}
	return nil
}

// Authorship contains authors and their affiliations.
type Authorship struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Affiliations indexed by affid
	Affiliations []*Affiliation `protobuf:"bytes,1,rep,name=affiliations,proto3" json:"affiliations,omitempty"`
	// Authors
	Authors       []*Author `protobuf:"bytes,2,rep,name=authors,proto3" json:"authors,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Authorship) Reset() {
	*x = Authorship{}
	mi := &file_spoke_arxiv_v1_0_arxiv_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Authorship) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Authorship) ProtoMessage() {}

func (x *Authorship) ProtoReflect() protoreflect.Message {
	mi := &file_spoke_arxiv_v1_0_arxiv_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Authorship.ProtoReflect.Descriptor instead.
func (*Authorship) Descriptor() ([]byte, []int) {
	return file_spoke_arxiv_v1_0_arxiv_proto_rawDescGZIP(), []int{5}
}

func (x *Authorship) GetAffiliations() []*Affiliation {
	if x != nil {
		return x.Affiliations
	}
	return nil
}

func (x *Authorship) GetAuthors() []*Author {
	if x != nil {
		return x.Authors
	}
	return nil
}

// Affiliation represents an institutional affiliation.
type Affiliation struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Affiliation index (referenced by authors)
	Affid int32 `protobuf:"varint,1,opt,name=affid,proto3" json:"affid,omitempty"`
	// Institution name
	Institution string `protobuf:"bytes,2,opt,name=institution,proto3" json:"institution,omitempty"`
	// Address (optional)
	Address       string `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Affiliation) Reset() {
	*x = Affiliation{}
	mi := &file_spoke_arxiv_v1_0_arxiv_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Affiliation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Affiliation) ProtoMessage() {}

func (x *Affiliation) ProtoReflect() protoreflect.Message {
	mi := &file_spoke_arxiv_v1_0_arxiv_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Affiliation.ProtoReflect.Descriptor instead.
func (*Affiliation) Descriptor() ([]byte, []int) {
	return file_spoke_arxiv_v1_0_arxiv_proto_rawDescGZIP(), []int{6}
}

func (x *Affiliation) GetAffid() int32 {
	if x != nil {
		return x.Affid
	}
	return 0
}

func (x *Affiliation) GetInstitution() string {
	if x != nil {
		return x.Institution
	}
	return ""
}

func (x *Affiliation) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

// Author represents a single author.
type Author struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Given name/forename (beforekey in arXiv terminology)
	Beforekey string `protobuf:"bytes,1,opt,name=beforekey,proto3" json:"beforekey,omitempty"`
	// Family name/surname (keyname in arXiv terminology)
	Keyname string `protobuf:"bytes,2,opt,name=keyname,proto3" json:"keyname,omitempty"`
	// Suffix (afterkey in arXiv terminology, e.g., Jr, III)
	Afterkey string `protobuf:"bytes,3,opt,name=afterkey,proto3" json:"afterkey,omitempty"`
	// Affiliation references (indexes into authorship.affiliations)
	Affref string `protobuf:"bytes,4,opt,name=affref,proto3" json:"affref,omitempty"`
	// Role (e.g., "appendix", "edited by")
	Role          string `protobuf:"bytes,5,opt,name=role,proto3" json:"role,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Author) Reset() {
	*x = Author{}
	mi := &file_spoke_arxiv_v1_0_arxiv_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Author) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Author) ProtoMessage() {}

func (x *Author) ProtoReflect() protoreflect.Message {
	mi := &file_spoke_arxiv_v1_0_arxiv_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Author.ProtoReflect.Descriptor instead.
func (*Author) Descriptor() ([]byte, []int) {
	return file_spoke_arxiv_v1_0_arxiv_proto_rawDescGZIP(), []int{7}
}

func (x *Author) GetBeforekey() string {
	if x != nil {
		return x.Beforekey
	}
	return ""
}

func (x *Author) GetKeyname() string {
	if x != nil {
		return x.Keyname
	}
	return ""
}

func (x *Author) GetAfterkey() string {
	if x != nil {
		return x.Afterkey
	}
	return ""
}

func (x *Author) GetAffref() string {
	if x != nil {
		return x.Affref
	}
	return ""
}

func (x *Author) GetRole() string {
	if x != nil {
		return x.Role
	}
	return ""
}

// Classification represents an external classification scheme entry.
type Classification struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Classification scheme (MSC1991, MSC2000, ACM1998, PACS2003)
	Scheme ClassificationScheme `protobuf:"varint,1,opt,name=scheme,proto3,enum=spoke.arxiv.v1_0.ClassificationScheme" json:"scheme,omitempty"`
	// Classification values (first is primary, rest are secondary)
	Value         []string `protobuf:"bytes,2,rep,name=value,proto3" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Classification) Reset() {
	*x = Classification{}
	mi := &file_spoke_arxiv_v1_0_arxiv_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Classification) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Classification) ProtoMessage() {}

func (x *Classification) ProtoReflect() protoreflect.Message {
	mi := &file_spoke_arxiv_v1_0_arxiv_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Classification.ProtoReflect.Descriptor instead.
func (*Classification) Descriptor() ([]byte, []int) {
	return file_spoke_arxiv_v1_0_arxiv_proto_rawDescGZIP(), []int{8}
}

func (x *Classification) GetScheme() ClassificationScheme {
	if x != nil {
		return x.Scheme
	}
	return ClassificationScheme_CLASSIFICATION_SCHEME_UNSPECIFIED
}

func (x *Classification) GetValue() []string {
	if x != nil {
		return x.Value
	}
	return nil
}

// Alternate contains alternate identifiers for the paper.
type Alternate struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Report numbers
	ReportNo []string `protobuf:"bytes,1,rep,name=report_no,json=reportNo,proto3" json:"report_no,omitempty"`
	// Journal references
	JournalRef []string `protobuf:"bytes,2,rep,name=journal_ref,json=journalRef,proto3" json:"journal_ref,omitempty"`
	// DOIs
	Doi           []string `protobuf:"bytes,3,rep,name=doi,proto3" json:"doi,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Alternate) Reset() {
	*x = Alternate{}
	mi := &file_spoke_arxiv_v1_0_arxiv_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Alternate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Alternate) ProtoMessage() {}

func (x *Alternate) ProtoReflect() protoreflect.Message {
	mi := &file_spoke_arxiv_v1_0_arxiv_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Alternate.ProtoReflect.Descriptor instead.
func (*Alternate) Descriptor() ([]byte, []int) {
	return file_spoke_arxiv_v1_0_arxiv_proto_rawDescGZIP(), []int{9}
}

func (x *Alternate) GetReportNo() []string {
	if x != nil {
		return x.ReportNo
	}
	return nil
}

func (x *Alternate) GetJournalRef() []string {
	if x != nil {
		return x.JournalRef
	}
	return nil
}

func (x *Alternate) GetDoi() []string {
	if x != nil {
		return x.Doi
	}
	return nil
}

// Attic stores legacy metadata from migrations.
type Attic struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Original content (XML encoded)
	Content string `protobuf:"bytes,1,opt,name=content,proto3" json:"content,omitempty"`
	// Conversion date
	Date string `protobuf:"bytes,2,opt,name=date,proto3" json:"date,omitempty"`
	// Conversion notes
	Note          string `protobuf:"bytes,3,opt,name=note,proto3" json:"note,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Attic) Reset() {
	*x = Attic{}
	mi := &file_spoke_arxiv_v1_0_arxiv_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Attic) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Attic) ProtoMessage() {}

func (x *Attic) ProtoReflect() protoreflect.Message {
	mi := &file_spoke_arxiv_v1_0_arxiv_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Attic.ProtoReflect.Descriptor instead.
func (*Attic) Descriptor() ([]byte, []int) {
	return file_spoke_arxiv_v1_0_arxiv_proto_rawDescGZIP(), []int{10}
}

func (x *Attic) GetContent() string {
	if x != nil {
		return x.Content
	}
	return ""
}

func (x *Attic) GetDate() string {
	if x != nil {
		return x.Date
	}
	return ""
}

func (x *Attic) GetNote() string {
	if x != nil {
		return x.Note
	}
	return ""
}

var File_spoke_arxiv_v1_0_arxiv_proto protoreflect.FileDescriptor

const file_spoke_arxiv_v1_0_arxiv_proto_rawDesc = "" +
	"\n" +
	"\x1cspoke/arxiv/v1_0/arxiv.proto\x12\x10spoke.arxiv.v1_0\x1a\x14hub/v1/options.proto\"\xae\n" +
	"\n" +
	"\x06Record\x12T\n" +
	"\n" +
	"identifier\x18\x01 \x01(\tB4\x8a\xb5\x180\n" +
	"\videntifiersZ\x05arxiv\xea\x03\x16arXiv paper identifier\xf8\x03\x01R\n" +
	"identifier\x12Q\n" +
	"\aprimary\x18\x02 \x01(\tB7\x8a\xb5\x183\n" +
	"\bsubjectsb\x05arxiv\xea\x03\x1cPrimary arXiv classification\xf8\x03\x01R\aprimary\x12J\n" +
	"\x05cross\x18\x03 \x03(\tB4\x8a\xb5\x180\n" +
	"\bsubjectsb\x05arxiv\xea\x03\x1cCross-listed classificationsR\x05cross\x12^\n" +
	"\tsubmitter\x18\x04 \x01(\v2\x1b.spoke.arxiv.v1_0.SubmitterB#\x8a\xb5\x18\x1f\n" +
	"\x05extra\xea\x03\x15Submitter informationR\tsubmitter\x12L\n" +
	"\x05proxy\x18\x05 \x01(\v2\x17.spoke.arxiv.v1_0.ProxyB\x1d\x8a\xb5\x18\x19\n" +
	"\x05extra\xea\x03\x0fProxy submitterR\x05proxy\x126\n" +
	"\aversion\x18\x06 \x01(\x05B\x1c\x8a\xb5\x18\x18\n" +
	"\x05extra\xea\x03\x0eVersion numberR\aversion\x12F\n" +
	"\x04date\x18\a \x01(\tB2\x8a\xb5\x18.\n" +
	"\x05datesR\tsubmitted\xa2\x01\aiso8601\xea\x03\x0fSubmission dateR\x04date\x12W\n" +
	"\x06source\x18\b \x01(\v2\x18.spoke.arxiv.v1_0.SourceB%\x8a\xb5\x18!\n" +
	"\x05extra\xea\x03\x17Source file informationR\x06source\x12R\n" +
	"\ahistory\x18\t \x03(\v2\x19.spoke.arxiv.v1_0.HistoryB\x1d\x8a\xb5\x18\x19\n" +
	"\x05extra\xea\x03\x0fVersion historyR\ahistory\x12$\n" +
	"\x05title\x18\n" +
	" \x01(\tB\x0e\x8a\xb5\x18\n" +
	"\n" +
	"\x05title\xf8\x03\x01R\x05title\x12a\n" +
	"\n" +
	"authorship\x18\v \x01(\v2\x1c.spoke.arxiv.v1_0.AuthorshipB#\x8a\xb5\x18\x1f\n" +
	"\x04self\xea\x03\x16Authorship informationR\n" +
	"authorship\x12s\n" +
	"\x0eclassification\x18\f \x03(\v2 .spoke.arxiv.v1_0.ClassificationB)\x8a\xb5\x18%\n" +
	"\bsubjects\xea\x03\x18External classificationsR\x0eclassification\x12]\n" +
	"\talternate\x18\r \x01(\v2\x1b.spoke.arxiv.v1_0.AlternateB\"\x8a\xb5\x18\x1e\n" +
	"\x04self\xea\x03\x15Alternate identifiersR\talternate\x129\n" +
	"\bcomments\x18\x0e \x03(\tB\x1d\x8a\xb5\x18\x19\n" +
	"\x05notes\xea\x03\x0fAuthor commentsR\bcomments\x12*\n" +
	"\babstract\x18\x0f \x03(\tB\x0e\x8a\xb5\x18\n" +
	"\n" +
	"\babstractR\babstract\x12L\n" +
	"\x05attic\x18\x10 \x03(\v2\x17.spoke.arxiv.v1_0.AtticB\x1d\x8a\xb5\x18\x19\n" +
	"\x05extra\xea\x03\x0fLegacy metadataR\x05attic:B\x8a\xb5\x18>\n" +
	"\x06Record\x10\x01\x1a2arXiv Record maps to Hub Record with PREPRINT type\"\x89\x01\n" +
	"\tSubmitter\x12;\n" +
	"\x05email\x18\x01 \x01(\tB%\x8a\xb5\x18!\n" +
	"\x05extra\xf2\x01\x05email\xea\x03\x0fSubmitter emailR\x05email\x12?\n" +
	"\n" +
	"identifier\x18\x02 \x01(\tB\x1f\x8a\xb5\x18\x1b\n" +
	"\x05extra\xea\x03\x11Submitter user IDR\n" +
	"identifier\"\x92\x01\n" +
	"\x05Proxy\x12;\n" +
	"\n" +
	"identifier\x18\x01 \x01(\tB\x1b\x8a\xb5\x18\x17\n" +
	"\x05extra\xea\x03\rProxy user IDR\n" +
	"identifier\x12L\n" +
	"\x11remote_identifier\x18\x02 \x01(\tB\x1f\x8a\xb5\x18\x1b\n" +
	"\x05extra\xea\x03\x11Remote identifierR\x10remoteIdentifier\"\xbe\x01\n" +
	"\x06Source\x12P\n" +
	"\x04type\x18\x01 \x01(\x0e2\x1c.spoke.arxiv.v1_0.SourceTypeB\x1e\x8a\xb5\x18\x1a\n" +
	"\x05extra\xea\x03\x10Source file typeR\x04type\x124\n" +
	"\x04size\x18\x02 \x01(\x03B \x8a\xb5\x18\x1c\n" +
	"\x05extra\xea\x03\x12File size in bytesR\x04size\x12,\n" +
	"\x03md5\x18\x03 \x01(\tB\x1a\x8a\xb5\x18\x16\n" +
	"\x05extra\xea\x03\fMD5 checksumR\x03md5\"\xc8\x01\n" +
	"\aHistory\x126\n" +
	"\aversion\x18\x01 \x01(\x05B\x1c\x8a\xb5\x18\x18\n" +
	"\x05extra\xea\x03\x0eVersion numberR\aversion\x121\n" +
	"\x04date\x18\x02 \x01(\tB\x1d\x8a\xb5\x18\x19\n" +
	"\x05extra\xea\x03\x0fSubmission dateR\x04date\x12R\n" +
	"\x06source\x18\x03 \x01(\v2\x18.spoke.arxiv.v1_0.SourceB \x8a\xb5\x18\x1c\n" +
	"\x05extra\xea\x03\x12Source informationR\x06source\"\xff\x01\n" +
	"\n" +
	"Authorship\x12e\n" +
	"\faffiliations\x18\x01 \x03(\v2\x1d.spoke.arxiv.v1_0.AffiliationB\"\x8a\xb5\x18\x1e\n" +
	"\x05extra\xea\x03\x14Indexed affiliationsR\faffiliations\x12V\n" +
	"\aauthors\x18\x02 \x03(\v2\x18.spoke.arxiv.v1_0.AuthorB\"\x8a\xb5\x18\x1e\n" +
	"\fcontributorsj\x06authorr\x06personR\aauthors:2\x8a\xb5\x18.\n" +
	"\x04self\x1a&arXiv Authorship extracts contributors\"\xfd\x01\n" +
	"\vAffiliation\x122\n" +
	"\x05affid\x18\x01 \x01(\x05B\x1c\x8a\xb5\x18\x18\n" +
	"\x05extra\xea\x03\x0eAffiliation IDR\x05affid\x12?\n" +
	"\vinstitution\x18\x02 \x01(\tB\x1d\x8a\xb5\x18\x19\n" +
	"\x04name\xea\x03\x10Institution nameR\vinstitution\x12;\n" +
	"\aaddress\x18\x03 \x01(\tB!\x8a\xb5\x18\x1d\n" +
	"\x05extra\xea\x03\x13Institution addressR\aaddress:<\x8a\xb5\x188\n" +
	"\vAffiliation\x1a)arXiv Affiliation maps to Hub Affiliation\"\x8b\x03\n" +
	"\x06Author\x12K\n" +
	"\tbeforekey\x18\x01 \x01(\tB-\x8a\xb5\x18)\n" +
	"\x11parsed_name.given\xea\x03\x13Given name/forenameR\tbeforekey\x12K\n" +
	"\akeyname\x18\x02 \x01(\tB1\x8a\xb5\x18-\n" +
	"\x12parsed_name.family\xea\x03\x13Family name/surname\xf8\x03\x01R\akeyname\x12B\n" +
	"\bafterkey\x18\x03 \x01(\tB&\x8a\xb5\x18\"\n" +
	"\x12parsed_name.suffix\xea\x03\vName suffixR\bafterkey\x12<\n" +
	"\x06affref\x18\x04 \x01(\tB$\x8a\xb5\x18 \n" +
	"\x05extra\xea\x03\x16Affiliation referencesR\x06affref\x12,\n" +
	"\x04role\x18\x05 \x01(\tB\x18\x8a\xb5\x18\x14\n" +
	"\x04role\xea\x03\vAuthor roleR\x04role:7\x8a\xb5\x183\n" +
	"\vContributor\x1a$arXiv Author maps to Hub Contributor\"\xed\x01\n" +
	"\x0eClassification\x12h\n" +
	"\x06scheme\x18\x01 \x01(\x0e2&.spoke.arxiv.v1_0.ClassificationSchemeB(\x8a\xb5\x18$\n" +
	"\n" +
	"vocabulary\xea\x03\x15Classification schemeR\x06scheme\x128\n" +
	"\x05value\x18\x02 \x03(\tB\"\x8a\xb5\x18\x1e\n" +
	"\x05value\xea\x03\x14Classification codesR\x05value:7\x8a\xb5\x183\n" +
	"\aSubject\x1a(arXiv Classification maps to Hub Subject\"\xfc\x01\n" +
	"\tAlternate\x12G\n" +
	"\treport_no\x18\x01 \x03(\tB*\x8a\xb5\x18&\n" +
	"\videntifiersZ\x06report\xea\x03\x0eReport numbersR\breportNo\x12S\n" +
	"\vjournal_ref\x18\x02 \x03(\tB2\x8a\xb5\x18.\n" +
	"\trelationsz\fpublished_in\xea\x03\x12Journal referencesR\n" +
	"journalRef\x12Q\n" +
	"\x03doi\x18\x03 \x03(\tB?\x8a\xb5\x18;\n" +
	"\videntifiersZ\x03doi\xa2\x01\x03doi\xf2\x01\x03doi\xea\x03\x1aDigital Object IdentifiersR\x03doi\"\xa6\x01\n" +
	"\x05Attic\x126\n" +
	"\acontent\x18\x01 \x01(\tB\x1c\x8a\xb5\x18\x18\n" +
	"\x05extra\xea\x03\x0eLegacy contentR\acontent\x121\n" +
	"\x04date\x18\x02 \x01(\tB\x1d\x8a\xb5\x18\x19\n" +
	"\x05extra\xea\x03\x0fConversion dateR\x04date\x122\n" +
	"\x04note\x18\x03 \x01(\tB\x1e\x8a\xb5\x18\x1a\n" +
	"\x05extra\xea\x03\x10Conversion notesR\x04note*\xb4\x01\n" +
	"\n" +
	"SourceType\x12\x1b\n" +
	"\x17SOURCE_TYPE_UNSPECIFIED\x10\x00\x12\x13\n" +
	"\x0fSOURCE_TYPE_TEX\x10\x01\x12\x1d\n" +
	"\x19SOURCE_TYPE_ENCRYPTED_TEX\x10\x02\x12\x12\n" +
	"\x0eSOURCE_TYPE_PS\x10\x03\x12\x13\n" +
	"\x0fSOURCE_TYPE_PDF\x10\x04\x12\x14\n" +
	"\x10SOURCE_TYPE_HTML\x10\x05\x12\x16\n" +
	"\x12SOURCE_TYPE_IGNORE\x10\x06*\xf7\x01\n" +
	"\x14ClassificationScheme\x12%\n" +
	"!CLASSIFICATION_SCHEME_UNSPECIFIED\x10\x00\x12,\n" +
	"\x1dCLASSIFICATION_SCHEME_MSC1991\x10\x01\x1a\t\x8a\xb5\x18\x05\n" +
	"\x03msc\x12,\n" +
	"\x1dCLASSIFICATION_SCHEME_MSC2000\x10\x02\x1a\t\x8a\xb5\x18\x05\n" +
	"\x03msc\x12,\n" +
	"\x1dCLASSIFICATION_SCHEME_ACM1998\x10\x03\x1a\t\x8a\xb5\x18\x05\n" +
	"\x03acm\x12.\n" +
	"\x1eCLASSIFICATION_SCHEME_PACS2003\x10\x04\x1a\n" +
	"\x8a\xb5\x18\x06\n" +
	"\x04pacsB\xca\x01\n" +
	"\x14com.spoke.arxiv.v1_0B\n" +
	"ArxivProtoP\x01ZHgithub.com/lehigh-university-libraries/crosswalk/gen/go/spoke/arxiv/v1_0\xa2\x02\x03SAV\xaa\x02\x0fSpoke.Arxiv.V10\xca\x02\x0fSpoke\\Arxiv\\V10\xe2\x02\x1bSpoke\\Arxiv\\V10\\GPBMetadata\xea\x02\x11Spoke::Arxiv::V10b\x06proto3"

var (
	file_spoke_arxiv_v1_0_arxiv_proto_rawDescOnce sync.Once
	file_spoke_arxiv_v1_0_arxiv_proto_rawDescData []byte
)

func file_spoke_arxiv_v1_0_arxiv_proto_rawDescGZIP() []byte {
	file_spoke_arxiv_v1_0_arxiv_proto_rawDescOnce.Do(func() {
		file_spoke_arxiv_v1_0_arxiv_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_spoke_arxiv_v1_0_arxiv_proto_rawDesc), len(file_spoke_arxiv_v1_0_arxiv_proto_rawDesc)))
	})
	return file_spoke_arxiv_v1_0_arxiv_proto_rawDescData
}

var file_spoke_arxiv_v1_0_arxiv_proto_enumTypes = make([]protoimpl.EnumInfo, 2)
var file_spoke_arxiv_v1_0_arxiv_proto_msgTypes = make([]protoimpl.MessageInfo, 11)
var file_spoke_arxiv_v1_0_arxiv_proto_goTypes = []any{
	(SourceType)(0),           // 0: spoke.arxiv.v1_0.SourceType
	(ClassificationScheme)(0), // 1: spoke.arxiv.v1_0.ClassificationScheme
	(*Record)(nil),            // 2: spoke.arxiv.v1_0.Record
	(*Submitter)(nil),         // 3: spoke.arxiv.v1_0.Submitter
	(*Proxy)(nil),             // 4: spoke.arxiv.v1_0.Proxy
	(*Source)(nil),            // 5: spoke.arxiv.v1_0.Source
	(*History)(nil),           // 6: spoke.arxiv.v1_0.History
	(*Authorship)(nil),        // 7: spoke.arxiv.v1_0.Authorship
	(*Affiliation)(nil),       // 8: spoke.arxiv.v1_0.Affiliation
	(*Author)(nil),            // 9: spoke.arxiv.v1_0.Author
	(*Classification)(nil),    // 10: spoke.arxiv.v1_0.Classification
	(*Alternate)(nil),         // 11: spoke.arxiv.v1_0.Alternate
	(*Attic)(nil),             // 12: spoke.arxiv.v1_0.Attic
}
var file_spoke_arxiv_v1_0_arxiv_proto_depIdxs = []int32{
	3,  // 0: spoke.arxiv.v1_0.Record.submitter:type_name -> spoke.arxiv.v1_0.Submitter
	4,  // 1: spoke.arxiv.v1_0.Record.proxy:type_name -> spoke.arxiv.v1_0.Proxy
	5,  // 2: spoke.arxiv.v1_0.Record.source:type_name -> spoke.arxiv.v1_0.Source
	6,  // 3: spoke.arxiv.v1_0.Record.history:type_name -> spoke.arxiv.v1_0.History
	7,  // 4: spoke.arxiv.v1_0.Record.authorship:type_name -> spoke.arxiv.v1_0.Authorship
	10, // 5: spoke.arxiv.v1_0.Record.classification:type_name -> spoke.arxiv.v1_0.Classification
	11, // 6: spoke.arxiv.v1_0.Record.alternate:type_name -> spoke.arxiv.v1_0.Alternate
	12, // 7: spoke.arxiv.v1_0.Record.attic:type_name -> spoke.arxiv.v1_0.Attic
	0,  // 8: spoke.arxiv.v1_0.Source.type:type_name -> spoke.arxiv.v1_0.SourceType
	5,  // 9: spoke.arxiv.v1_0.History.source:type_name -> spoke.arxiv.v1_0.Source
	8,  // 10: spoke.arxiv.v1_0.Authorship.affiliations:type_name -> spoke.arxiv.v1_0.Affiliation
	9,  // 11: spoke.arxiv.v1_0.Authorship.authors:type_name -> spoke.arxiv.v1_0.Author
	1,  // 12: spoke.arxiv.v1_0.Classification.scheme:type_name -> spoke.arxiv.v1_0.ClassificationScheme
	13, // [13:13] is the sub-list for method output_type
	13, // [13:13] is the sub-list for method input_type
	13, // [13:13] is the sub-list for extension type_name
	13, // [13:13] is the sub-list for extension extendee
	0,  // [0:13] is the sub-list for field type_name
}

func init() { file_spoke_arxiv_v1_0_arxiv_proto_init() }
func file_spoke_arxiv_v1_0_arxiv_proto_init() {
	if File_spoke_arxiv_v1_0_arxiv_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_spoke_arxiv_v1_0_arxiv_proto_rawDesc), len(file_spoke_arxiv_v1_0_arxiv_proto_rawDesc)),
			NumEnums:      2,
			NumMessages:   11,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_spoke_arxiv_v1_0_arxiv_proto_goTypes,
		DependencyIndexes: file_spoke_arxiv_v1_0_arxiv_proto_depIdxs,
		EnumInfos:         file_spoke_arxiv_v1_0_arxiv_proto_enumTypes,
		MessageInfos:      file_spoke_arxiv_v1_0_arxiv_proto_msgTypes,
	}.Build()
	File_spoke_arxiv_v1_0_arxiv_proto = out.File
	file_spoke_arxiv_v1_0_arxiv_proto_goTypes = nil
	file_spoke_arxiv_v1_0_arxiv_proto_depIdxs = nil
}
