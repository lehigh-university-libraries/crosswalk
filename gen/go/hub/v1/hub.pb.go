// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        (unknown)
// source: hub/v1/hub.proto

package hubv1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	structpb "google.golang.org/protobuf/types/known/structpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// GroupType identifies the type of grouping.
type GroupType int32

const (
	GroupType_GROUP_TYPE_UNSPECIFIED GroupType = 0
	GroupType_GROUP_TYPE_ISSUE       GroupType = 1 // Journal issue
	GroupType_GROUP_TYPE_COLLECTION  GroupType = 2 // Repository collection
	GroupType_GROUP_TYPE_SERIES      GroupType = 3 // Monograph series
	GroupType_GROUP_TYPE_VOLUME      GroupType = 4 // Multi-volume work
)

// Enum value maps for GroupType.
var (
	GroupType_name = map[int32]string{
		0: "GROUP_TYPE_UNSPECIFIED",
		1: "GROUP_TYPE_ISSUE",
		2: "GROUP_TYPE_COLLECTION",
		3: "GROUP_TYPE_SERIES",
		4: "GROUP_TYPE_VOLUME",
	}
	GroupType_value = map[string]int32{
		"GROUP_TYPE_UNSPECIFIED": 0,
		"GROUP_TYPE_ISSUE":       1,
		"GROUP_TYPE_COLLECTION":  2,
		"GROUP_TYPE_SERIES":      3,
		"GROUP_TYPE_VOLUME":      4,
	}
)

func (x GroupType) Enum() *GroupType {
	p := new(GroupType)
	*p = x
	return p
}

func (x GroupType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (GroupType) Descriptor() protoreflect.EnumDescriptor {
	return file_hub_v1_hub_proto_enumTypes[0].Descriptor()
}

func (GroupType) Type() protoreflect.EnumType {
	return &file_hub_v1_hub_proto_enumTypes[0]
}

func (x GroupType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use GroupType.Descriptor instead.
func (GroupType) EnumDescriptor() ([]byte, []int) {
	return file_hub_v1_hub_proto_rawDescGZIP(), []int{0}
}

// ContributorType indicates whether a contributor is a person or organization.
type ContributorType int32

const (
	ContributorType_CONTRIBUTOR_TYPE_UNSPECIFIED  ContributorType = 0
	ContributorType_CONTRIBUTOR_TYPE_PERSON       ContributorType = 1
	ContributorType_CONTRIBUTOR_TYPE_ORGANIZATION ContributorType = 2
)

// Enum value maps for ContributorType.
var (
	ContributorType_name = map[int32]string{
		0: "CONTRIBUTOR_TYPE_UNSPECIFIED",
		1: "CONTRIBUTOR_TYPE_PERSON",
		2: "CONTRIBUTOR_TYPE_ORGANIZATION",
	}
	ContributorType_value = map[string]int32{
		"CONTRIBUTOR_TYPE_UNSPECIFIED":  0,
		"CONTRIBUTOR_TYPE_PERSON":       1,
		"CONTRIBUTOR_TYPE_ORGANIZATION": 2,
	}
)

func (x ContributorType) Enum() *ContributorType {
	p := new(ContributorType)
	*p = x
	return p
}

func (x ContributorType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ContributorType) Descriptor() protoreflect.EnumDescriptor {
	return file_hub_v1_hub_proto_enumTypes[1].Descriptor()
}

func (ContributorType) Type() protoreflect.EnumType {
	return &file_hub_v1_hub_proto_enumTypes[1]
}

func (x ContributorType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ContributorType.Descriptor instead.
func (ContributorType) EnumDescriptor() ([]byte, []int) {
	return file_hub_v1_hub_proto_rawDescGZIP(), []int{1}
}

// DateType indicates the semantic meaning of a date.
type DateType int32

const (
	DateType_DATE_TYPE_UNSPECIFIED DateType = 0
	DateType_DATE_TYPE_ISSUED      DateType = 1
	DateType_DATE_TYPE_CREATED     DateType = 2
	DateType_DATE_TYPE_CAPTURED    DateType = 3
	DateType_DATE_TYPE_COPYRIGHT   DateType = 4
	DateType_DATE_TYPE_MODIFIED    DateType = 5
	DateType_DATE_TYPE_AVAILABLE   DateType = 6
	DateType_DATE_TYPE_SUBMITTED   DateType = 7
	DateType_DATE_TYPE_ACCEPTED    DateType = 8
	DateType_DATE_TYPE_PUBLISHED   DateType = 9
	DateType_DATE_TYPE_OTHER       DateType = 10
	DateType_DATE_TYPE_VALID       DateType = 11 // Date resource is valid
	DateType_DATE_TYPE_UPDATED     DateType = 12 // Date resource was updated
	DateType_DATE_TYPE_COLLECTED   DateType = 13 // Date data was collected
)

// Enum value maps for DateType.
var (
	DateType_name = map[int32]string{
		0:  "DATE_TYPE_UNSPECIFIED",
		1:  "DATE_TYPE_ISSUED",
		2:  "DATE_TYPE_CREATED",
		3:  "DATE_TYPE_CAPTURED",
		4:  "DATE_TYPE_COPYRIGHT",
		5:  "DATE_TYPE_MODIFIED",
		6:  "DATE_TYPE_AVAILABLE",
		7:  "DATE_TYPE_SUBMITTED",
		8:  "DATE_TYPE_ACCEPTED",
		9:  "DATE_TYPE_PUBLISHED",
		10: "DATE_TYPE_OTHER",
		11: "DATE_TYPE_VALID",
		12: "DATE_TYPE_UPDATED",
		13: "DATE_TYPE_COLLECTED",
	}
	DateType_value = map[string]int32{
		"DATE_TYPE_UNSPECIFIED": 0,
		"DATE_TYPE_ISSUED":      1,
		"DATE_TYPE_CREATED":     2,
		"DATE_TYPE_CAPTURED":    3,
		"DATE_TYPE_COPYRIGHT":   4,
		"DATE_TYPE_MODIFIED":    5,
		"DATE_TYPE_AVAILABLE":   6,
		"DATE_TYPE_SUBMITTED":   7,
		"DATE_TYPE_ACCEPTED":    8,
		"DATE_TYPE_PUBLISHED":   9,
		"DATE_TYPE_OTHER":       10,
		"DATE_TYPE_VALID":       11,
		"DATE_TYPE_UPDATED":     12,
		"DATE_TYPE_COLLECTED":   13,
	}
)

func (x DateType) Enum() *DateType {
	p := new(DateType)
	*p = x
	return p
}

func (x DateType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (DateType) Descriptor() protoreflect.EnumDescriptor {
	return file_hub_v1_hub_proto_enumTypes[2].Descriptor()
}

func (DateType) Type() protoreflect.EnumType {
	return &file_hub_v1_hub_proto_enumTypes[2]
}

func (x DateType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use DateType.Descriptor instead.
func (DateType) EnumDescriptor() ([]byte, []int) {
	return file_hub_v1_hub_proto_rawDescGZIP(), []int{2}
}

// DatePrecision indicates the granularity of a date.
type DatePrecision int32

const (
	DatePrecision_DATE_PRECISION_UNSPECIFIED DatePrecision = 0
	DatePrecision_DATE_PRECISION_YEAR        DatePrecision = 1
	DatePrecision_DATE_PRECISION_MONTH       DatePrecision = 2
	DatePrecision_DATE_PRECISION_DAY         DatePrecision = 3
	DatePrecision_DATE_PRECISION_TIME        DatePrecision = 4
	DatePrecision_DATE_PRECISION_DECADE      DatePrecision = 5
	DatePrecision_DATE_PRECISION_CENTURY     DatePrecision = 6
)

// Enum value maps for DatePrecision.
var (
	DatePrecision_name = map[int32]string{
		0: "DATE_PRECISION_UNSPECIFIED",
		1: "DATE_PRECISION_YEAR",
		2: "DATE_PRECISION_MONTH",
		3: "DATE_PRECISION_DAY",
		4: "DATE_PRECISION_TIME",
		5: "DATE_PRECISION_DECADE",
		6: "DATE_PRECISION_CENTURY",
	}
	DatePrecision_value = map[string]int32{
		"DATE_PRECISION_UNSPECIFIED": 0,
		"DATE_PRECISION_YEAR":        1,
		"DATE_PRECISION_MONTH":       2,
		"DATE_PRECISION_DAY":         3,
		"DATE_PRECISION_TIME":        4,
		"DATE_PRECISION_DECADE":      5,
		"DATE_PRECISION_CENTURY":     6,
	}
)

func (x DatePrecision) Enum() *DatePrecision {
	p := new(DatePrecision)
	*p = x
	return p
}

func (x DatePrecision) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (DatePrecision) Descriptor() protoreflect.EnumDescriptor {
	return file_hub_v1_hub_proto_enumTypes[3].Descriptor()
}

func (DatePrecision) Type() protoreflect.EnumType {
	return &file_hub_v1_hub_proto_enumTypes[3]
}

func (x DatePrecision) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use DatePrecision.Descriptor instead.
func (DatePrecision) EnumDescriptor() ([]byte, []int) {
	return file_hub_v1_hub_proto_rawDescGZIP(), []int{3}
}

// DateQualifier indicates uncertainty or approximation.
type DateQualifier int32

const (
	DateQualifier_DATE_QUALIFIER_UNSPECIFIED DateQualifier = 0
	DateQualifier_DATE_QUALIFIER_APPROXIMATE DateQualifier = 1 // ~
	DateQualifier_DATE_QUALIFIER_UNCERTAIN   DateQualifier = 2 // ?
	DateQualifier_DATE_QUALIFIER_BOTH        DateQualifier = 3 // %
)

// Enum value maps for DateQualifier.
var (
	DateQualifier_name = map[int32]string{
		0: "DATE_QUALIFIER_UNSPECIFIED",
		1: "DATE_QUALIFIER_APPROXIMATE",
		2: "DATE_QUALIFIER_UNCERTAIN",
		3: "DATE_QUALIFIER_BOTH",
	}
	DateQualifier_value = map[string]int32{
		"DATE_QUALIFIER_UNSPECIFIED": 0,
		"DATE_QUALIFIER_APPROXIMATE": 1,
		"DATE_QUALIFIER_UNCERTAIN":   2,
		"DATE_QUALIFIER_BOTH":        3,
	}
)

func (x DateQualifier) Enum() *DateQualifier {
	p := new(DateQualifier)
	*p = x
	return p
}

func (x DateQualifier) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (DateQualifier) Descriptor() protoreflect.EnumDescriptor {
	return file_hub_v1_hub_proto_enumTypes[4].Descriptor()
}

func (DateQualifier) Type() protoreflect.EnumType {
	return &file_hub_v1_hub_proto_enumTypes[4]
}

func (x DateQualifier) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use DateQualifier.Descriptor instead.
func (DateQualifier) EnumDescriptor() ([]byte, []int) {
	return file_hub_v1_hub_proto_rawDescGZIP(), []int{4}
}

// IdentifierType represents the type of identifier.
type IdentifierType int32

const (
	IdentifierType_IDENTIFIER_TYPE_UNSPECIFIED   IdentifierType = 0
	IdentifierType_IDENTIFIER_TYPE_DOI           IdentifierType = 1
	IdentifierType_IDENTIFIER_TYPE_URL           IdentifierType = 2
	IdentifierType_IDENTIFIER_TYPE_HANDLE        IdentifierType = 3
	IdentifierType_IDENTIFIER_TYPE_ISBN          IdentifierType = 4
	IdentifierType_IDENTIFIER_TYPE_ISSN          IdentifierType = 5
	IdentifierType_IDENTIFIER_TYPE_ORCID         IdentifierType = 6
	IdentifierType_IDENTIFIER_TYPE_PMID          IdentifierType = 7
	IdentifierType_IDENTIFIER_TYPE_PMCID         IdentifierType = 8
	IdentifierType_IDENTIFIER_TYPE_ARXIV         IdentifierType = 9
	IdentifierType_IDENTIFIER_TYPE_LOCAL         IdentifierType = 10
	IdentifierType_IDENTIFIER_TYPE_PID           IdentifierType = 11
	IdentifierType_IDENTIFIER_TYPE_NID           IdentifierType = 12
	IdentifierType_IDENTIFIER_TYPE_UUID          IdentifierType = 13
	IdentifierType_IDENTIFIER_TYPE_ISNI          IdentifierType = 14
	IdentifierType_IDENTIFIER_TYPE_REPORT_NUMBER IdentifierType = 15
	IdentifierType_IDENTIFIER_TYPE_CALL_NUMBER   IdentifierType = 16
)

// Enum value maps for IdentifierType.
var (
	IdentifierType_name = map[int32]string{
		0:  "IDENTIFIER_TYPE_UNSPECIFIED",
		1:  "IDENTIFIER_TYPE_DOI",
		2:  "IDENTIFIER_TYPE_URL",
		3:  "IDENTIFIER_TYPE_HANDLE",
		4:  "IDENTIFIER_TYPE_ISBN",
		5:  "IDENTIFIER_TYPE_ISSN",
		6:  "IDENTIFIER_TYPE_ORCID",
		7:  "IDENTIFIER_TYPE_PMID",
		8:  "IDENTIFIER_TYPE_PMCID",
		9:  "IDENTIFIER_TYPE_ARXIV",
		10: "IDENTIFIER_TYPE_LOCAL",
		11: "IDENTIFIER_TYPE_PID",
		12: "IDENTIFIER_TYPE_NID",
		13: "IDENTIFIER_TYPE_UUID",
		14: "IDENTIFIER_TYPE_ISNI",
		15: "IDENTIFIER_TYPE_REPORT_NUMBER",
		16: "IDENTIFIER_TYPE_CALL_NUMBER",
	}
	IdentifierType_value = map[string]int32{
		"IDENTIFIER_TYPE_UNSPECIFIED":   0,
		"IDENTIFIER_TYPE_DOI":           1,
		"IDENTIFIER_TYPE_URL":           2,
		"IDENTIFIER_TYPE_HANDLE":        3,
		"IDENTIFIER_TYPE_ISBN":          4,
		"IDENTIFIER_TYPE_ISSN":          5,
		"IDENTIFIER_TYPE_ORCID":         6,
		"IDENTIFIER_TYPE_PMID":          7,
		"IDENTIFIER_TYPE_PMCID":         8,
		"IDENTIFIER_TYPE_ARXIV":         9,
		"IDENTIFIER_TYPE_LOCAL":         10,
		"IDENTIFIER_TYPE_PID":           11,
		"IDENTIFIER_TYPE_NID":           12,
		"IDENTIFIER_TYPE_UUID":          13,
		"IDENTIFIER_TYPE_ISNI":          14,
		"IDENTIFIER_TYPE_REPORT_NUMBER": 15,
		"IDENTIFIER_TYPE_CALL_NUMBER":   16,
	}
)

func (x IdentifierType) Enum() *IdentifierType {
	p := new(IdentifierType)
	*p = x
	return p
}

func (x IdentifierType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (IdentifierType) Descriptor() protoreflect.EnumDescriptor {
	return file_hub_v1_hub_proto_enumTypes[5].Descriptor()
}

func (IdentifierType) Type() protoreflect.EnumType {
	return &file_hub_v1_hub_proto_enumTypes[5]
}

func (x IdentifierType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use IdentifierType.Descriptor instead.
func (IdentifierType) EnumDescriptor() ([]byte, []int) {
	return file_hub_v1_hub_proto_rawDescGZIP(), []int{5}
}

// SubjectType indicates the type of subject (topic, name, place).
type SubjectType int32

const (
	SubjectType_SUBJECT_TYPE_UNSPECIFIED SubjectType = 0
	SubjectType_SUBJECT_TYPE_TOPIC       SubjectType = 1
	SubjectType_SUBJECT_TYPE_NAME        SubjectType = 2
	SubjectType_SUBJECT_TYPE_GEOGRAPHIC  SubjectType = 3
	SubjectType_SUBJECT_TYPE_TEMPORAL    SubjectType = 4
	SubjectType_SUBJECT_TYPE_GENRE       SubjectType = 5
	SubjectType_SUBJECT_TYPE_TITLE       SubjectType = 6
)

// Enum value maps for SubjectType.
var (
	SubjectType_name = map[int32]string{
		0: "SUBJECT_TYPE_UNSPECIFIED",
		1: "SUBJECT_TYPE_TOPIC",
		2: "SUBJECT_TYPE_NAME",
		3: "SUBJECT_TYPE_GEOGRAPHIC",
		4: "SUBJECT_TYPE_TEMPORAL",
		5: "SUBJECT_TYPE_GENRE",
		6: "SUBJECT_TYPE_TITLE",
	}
	SubjectType_value = map[string]int32{
		"SUBJECT_TYPE_UNSPECIFIED": 0,
		"SUBJECT_TYPE_TOPIC":       1,
		"SUBJECT_TYPE_NAME":        2,
		"SUBJECT_TYPE_GEOGRAPHIC":  3,
		"SUBJECT_TYPE_TEMPORAL":    4,
		"SUBJECT_TYPE_GENRE":       5,
		"SUBJECT_TYPE_TITLE":       6,
	}
)

func (x SubjectType) Enum() *SubjectType {
	p := new(SubjectType)
	*p = x
	return p
}

func (x SubjectType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SubjectType) Descriptor() protoreflect.EnumDescriptor {
	return file_hub_v1_hub_proto_enumTypes[6].Descriptor()
}

func (SubjectType) Type() protoreflect.EnumType {
	return &file_hub_v1_hub_proto_enumTypes[6]
}

func (x SubjectType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SubjectType.Descriptor instead.
func (SubjectType) EnumDescriptor() ([]byte, []int) {
	return file_hub_v1_hub_proto_rawDescGZIP(), []int{6}
}

// SubjectVocabulary identifies the vocabulary a subject term comes from.
type SubjectVocabulary int32

const (
	SubjectVocabulary_SUBJECT_VOCABULARY_UNSPECIFIED SubjectVocabulary = 0
	SubjectVocabulary_SUBJECT_VOCABULARY_LCSH        SubjectVocabulary = 1  // Library of Congress Subject Headings
	SubjectVocabulary_SUBJECT_VOCABULARY_MESH        SubjectVocabulary = 2  // Medical Subject Headings
	SubjectVocabulary_SUBJECT_VOCABULARY_AAT         SubjectVocabulary = 3  // Art & Architecture Thesaurus
	SubjectVocabulary_SUBJECT_VOCABULARY_FAST        SubjectVocabulary = 4  // Faceted Application of Subject Terminology
	SubjectVocabulary_SUBJECT_VOCABULARY_DDC         SubjectVocabulary = 5  // Dewey Decimal Classification
	SubjectVocabulary_SUBJECT_VOCABULARY_LCC         SubjectVocabulary = 6  // Library of Congress Classification
	SubjectVocabulary_SUBJECT_VOCABULARY_KEYWORDS    SubjectVocabulary = 7  // Free-form keywords
	SubjectVocabulary_SUBJECT_VOCABULARY_GENRE       SubjectVocabulary = 8  // Genre terms
	SubjectVocabulary_SUBJECT_VOCABULARY_LOCAL       SubjectVocabulary = 9  // Local/institutional vocabulary
	SubjectVocabulary_SUBJECT_VOCABULARY_GETTY_TGN   SubjectVocabulary = 10 // Getty Thesaurus of Geographic Names
	SubjectVocabulary_SUBJECT_VOCABULARY_LCNAF       SubjectVocabulary = 11 // Library of Congress Name Authority File
	SubjectVocabulary_SUBJECT_VOCABULARY_ARXIV       SubjectVocabulary = 12 // arXiv subject classifications
	SubjectVocabulary_SUBJECT_VOCABULARY_MSC         SubjectVocabulary = 13 // Mathematics Subject Classification
	SubjectVocabulary_SUBJECT_VOCABULARY_ACM         SubjectVocabulary = 14 // ACM Computing Classification System
	SubjectVocabulary_SUBJECT_VOCABULARY_PACS        SubjectVocabulary = 15 // Physics and Astronomy Classification Scheme
)

// Enum value maps for SubjectVocabulary.
var (
	SubjectVocabulary_name = map[int32]string{
		0:  "SUBJECT_VOCABULARY_UNSPECIFIED",
		1:  "SUBJECT_VOCABULARY_LCSH",
		2:  "SUBJECT_VOCABULARY_MESH",
		3:  "SUBJECT_VOCABULARY_AAT",
		4:  "SUBJECT_VOCABULARY_FAST",
		5:  "SUBJECT_VOCABULARY_DDC",
		6:  "SUBJECT_VOCABULARY_LCC",
		7:  "SUBJECT_VOCABULARY_KEYWORDS",
		8:  "SUBJECT_VOCABULARY_GENRE",
		9:  "SUBJECT_VOCABULARY_LOCAL",
		10: "SUBJECT_VOCABULARY_GETTY_TGN",
		11: "SUBJECT_VOCABULARY_LCNAF",
		12: "SUBJECT_VOCABULARY_ARXIV",
		13: "SUBJECT_VOCABULARY_MSC",
		14: "SUBJECT_VOCABULARY_ACM",
		15: "SUBJECT_VOCABULARY_PACS",
	}
	SubjectVocabulary_value = map[string]int32{
		"SUBJECT_VOCABULARY_UNSPECIFIED": 0,
		"SUBJECT_VOCABULARY_LCSH":        1,
		"SUBJECT_VOCABULARY_MESH":        2,
		"SUBJECT_VOCABULARY_AAT":         3,
		"SUBJECT_VOCABULARY_FAST":        4,
		"SUBJECT_VOCABULARY_DDC":         5,
		"SUBJECT_VOCABULARY_LCC":         6,
		"SUBJECT_VOCABULARY_KEYWORDS":    7,
		"SUBJECT_VOCABULARY_GENRE":       8,
		"SUBJECT_VOCABULARY_LOCAL":       9,
		"SUBJECT_VOCABULARY_GETTY_TGN":   10,
		"SUBJECT_VOCABULARY_LCNAF":       11,
		"SUBJECT_VOCABULARY_ARXIV":       12,
		"SUBJECT_VOCABULARY_MSC":         13,
		"SUBJECT_VOCABULARY_ACM":         14,
		"SUBJECT_VOCABULARY_PACS":        15,
	}
)

func (x SubjectVocabulary) Enum() *SubjectVocabulary {
	p := new(SubjectVocabulary)
	*p = x
	return p
}

func (x SubjectVocabulary) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SubjectVocabulary) Descriptor() protoreflect.EnumDescriptor {
	return file_hub_v1_hub_proto_enumTypes[7].Descriptor()
}

func (SubjectVocabulary) Type() protoreflect.EnumType {
	return &file_hub_v1_hub_proto_enumTypes[7]
}

func (x SubjectVocabulary) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SubjectVocabulary.Descriptor instead.
func (SubjectVocabulary) EnumDescriptor() ([]byte, []int) {
	return file_hub_v1_hub_proto_rawDescGZIP(), []int{7}
}

// ResourceTypeValue is a normalized resource type.
type ResourceTypeValue int32

const (
	ResourceTypeValue_RESOURCE_TYPE_UNSPECIFIED           ResourceTypeValue = 0
	ResourceTypeValue_RESOURCE_TYPE_ARTICLE               ResourceTypeValue = 1
	ResourceTypeValue_RESOURCE_TYPE_BOOK                  ResourceTypeValue = 2
	ResourceTypeValue_RESOURCE_TYPE_BOOK_CHAPTER          ResourceTypeValue = 3
	ResourceTypeValue_RESOURCE_TYPE_CONFERENCE_PAPER      ResourceTypeValue = 4
	ResourceTypeValue_RESOURCE_TYPE_DATASET               ResourceTypeValue = 5
	ResourceTypeValue_RESOURCE_TYPE_DISSERTATION          ResourceTypeValue = 6
	ResourceTypeValue_RESOURCE_TYPE_THESIS                ResourceTypeValue = 7
	ResourceTypeValue_RESOURCE_TYPE_IMAGE                 ResourceTypeValue = 8
	ResourceTypeValue_RESOURCE_TYPE_JOURNAL               ResourceTypeValue = 9
	ResourceTypeValue_RESOURCE_TYPE_REPORT                ResourceTypeValue = 10
	ResourceTypeValue_RESOURCE_TYPE_TECHNICAL_REPORT      ResourceTypeValue = 11
	ResourceTypeValue_RESOURCE_TYPE_WORKING_PAPER         ResourceTypeValue = 12
	ResourceTypeValue_RESOURCE_TYPE_PREPRINT              ResourceTypeValue = 13
	ResourceTypeValue_RESOURCE_TYPE_POSTER                ResourceTypeValue = 14
	ResourceTypeValue_RESOURCE_TYPE_PRESENTATION          ResourceTypeValue = 15
	ResourceTypeValue_RESOURCE_TYPE_SOFTWARE              ResourceTypeValue = 16
	ResourceTypeValue_RESOURCE_TYPE_VIDEO                 ResourceTypeValue = 17
	ResourceTypeValue_RESOURCE_TYPE_AUDIO                 ResourceTypeValue = 18
	ResourceTypeValue_RESOURCE_TYPE_MAP                   ResourceTypeValue = 19
	ResourceTypeValue_RESOURCE_TYPE_NEWSPAPER             ResourceTypeValue = 20
	ResourceTypeValue_RESOURCE_TYPE_NEWSPAPER_ARTICLE     ResourceTypeValue = 21
	ResourceTypeValue_RESOURCE_TYPE_PERIODICAL            ResourceTypeValue = 22
	ResourceTypeValue_RESOURCE_TYPE_COLLECTION            ResourceTypeValue = 23
	ResourceTypeValue_RESOURCE_TYPE_ARCHIVAL_MATERIAL     ResourceTypeValue = 24
	ResourceTypeValue_RESOURCE_TYPE_MANUSCRIPT            ResourceTypeValue = 25
	ResourceTypeValue_RESOURCE_TYPE_PATENT                ResourceTypeValue = 26
	ResourceTypeValue_RESOURCE_TYPE_STANDARD              ResourceTypeValue = 27
	ResourceTypeValue_RESOURCE_TYPE_WEBPAGE               ResourceTypeValue = 28
	ResourceTypeValue_RESOURCE_TYPE_OTHER                 ResourceTypeValue = 29
	ResourceTypeValue_RESOURCE_TYPE_PEER_REVIEW           ResourceTypeValue = 30 // Peer review document
	ResourceTypeValue_RESOURCE_TYPE_INTERACTIVE           ResourceTypeValue = 31 // Interactive resource
	ResourceTypeValue_RESOURCE_TYPE_OBJECT                ResourceTypeValue = 32 // Physical object
	ResourceTypeValue_RESOURCE_TYPE_CONFERENCE_PROCEEDING ResourceTypeValue = 33 // Conference proceedings (collection)
	ResourceTypeValue_RESOURCE_TYPE_TEXT                  ResourceTypeValue = 34 // Generic text resource
)

// Enum value maps for ResourceTypeValue.
var (
	ResourceTypeValue_name = map[int32]string{
		0:  "RESOURCE_TYPE_UNSPECIFIED",
		1:  "RESOURCE_TYPE_ARTICLE",
		2:  "RESOURCE_TYPE_BOOK",
		3:  "RESOURCE_TYPE_BOOK_CHAPTER",
		4:  "RESOURCE_TYPE_CONFERENCE_PAPER",
		5:  "RESOURCE_TYPE_DATASET",
		6:  "RESOURCE_TYPE_DISSERTATION",
		7:  "RESOURCE_TYPE_THESIS",
		8:  "RESOURCE_TYPE_IMAGE",
		9:  "RESOURCE_TYPE_JOURNAL",
		10: "RESOURCE_TYPE_REPORT",
		11: "RESOURCE_TYPE_TECHNICAL_REPORT",
		12: "RESOURCE_TYPE_WORKING_PAPER",
		13: "RESOURCE_TYPE_PREPRINT",
		14: "RESOURCE_TYPE_POSTER",
		15: "RESOURCE_TYPE_PRESENTATION",
		16: "RESOURCE_TYPE_SOFTWARE",
		17: "RESOURCE_TYPE_VIDEO",
		18: "RESOURCE_TYPE_AUDIO",
		19: "RESOURCE_TYPE_MAP",
		20: "RESOURCE_TYPE_NEWSPAPER",
		21: "RESOURCE_TYPE_NEWSPAPER_ARTICLE",
		22: "RESOURCE_TYPE_PERIODICAL",
		23: "RESOURCE_TYPE_COLLECTION",
		24: "RESOURCE_TYPE_ARCHIVAL_MATERIAL",
		25: "RESOURCE_TYPE_MANUSCRIPT",
		26: "RESOURCE_TYPE_PATENT",
		27: "RESOURCE_TYPE_STANDARD",
		28: "RESOURCE_TYPE_WEBPAGE",
		29: "RESOURCE_TYPE_OTHER",
		30: "RESOURCE_TYPE_PEER_REVIEW",
		31: "RESOURCE_TYPE_INTERACTIVE",
		32: "RESOURCE_TYPE_OBJECT",
		33: "RESOURCE_TYPE_CONFERENCE_PROCEEDING",
		34: "RESOURCE_TYPE_TEXT",
	}
	ResourceTypeValue_value = map[string]int32{
		"RESOURCE_TYPE_UNSPECIFIED":           0,
		"RESOURCE_TYPE_ARTICLE":               1,
		"RESOURCE_TYPE_BOOK":                  2,
		"RESOURCE_TYPE_BOOK_CHAPTER":          3,
		"RESOURCE_TYPE_CONFERENCE_PAPER":      4,
		"RESOURCE_TYPE_DATASET":               5,
		"RESOURCE_TYPE_DISSERTATION":          6,
		"RESOURCE_TYPE_THESIS":                7,
		"RESOURCE_TYPE_IMAGE":                 8,
		"RESOURCE_TYPE_JOURNAL":               9,
		"RESOURCE_TYPE_REPORT":                10,
		"RESOURCE_TYPE_TECHNICAL_REPORT":      11,
		"RESOURCE_TYPE_WORKING_PAPER":         12,
		"RESOURCE_TYPE_PREPRINT":              13,
		"RESOURCE_TYPE_POSTER":                14,
		"RESOURCE_TYPE_PRESENTATION":          15,
		"RESOURCE_TYPE_SOFTWARE":              16,
		"RESOURCE_TYPE_VIDEO":                 17,
		"RESOURCE_TYPE_AUDIO":                 18,
		"RESOURCE_TYPE_MAP":                   19,
		"RESOURCE_TYPE_NEWSPAPER":             20,
		"RESOURCE_TYPE_NEWSPAPER_ARTICLE":     21,
		"RESOURCE_TYPE_PERIODICAL":            22,
		"RESOURCE_TYPE_COLLECTION":            23,
		"RESOURCE_TYPE_ARCHIVAL_MATERIAL":     24,
		"RESOURCE_TYPE_MANUSCRIPT":            25,
		"RESOURCE_TYPE_PATENT":                26,
		"RESOURCE_TYPE_STANDARD":              27,
		"RESOURCE_TYPE_WEBPAGE":               28,
		"RESOURCE_TYPE_OTHER":                 29,
		"RESOURCE_TYPE_PEER_REVIEW":           30,
		"RESOURCE_TYPE_INTERACTIVE":           31,
		"RESOURCE_TYPE_OBJECT":                32,
		"RESOURCE_TYPE_CONFERENCE_PROCEEDING": 33,
		"RESOURCE_TYPE_TEXT":                  34,
	}
)

func (x ResourceTypeValue) Enum() *ResourceTypeValue {
	p := new(ResourceTypeValue)
	*p = x
	return p
}

func (x ResourceTypeValue) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ResourceTypeValue) Descriptor() protoreflect.EnumDescriptor {
	return file_hub_v1_hub_proto_enumTypes[8].Descriptor()
}

func (ResourceTypeValue) Type() protoreflect.EnumType {
	return &file_hub_v1_hub_proto_enumTypes[8]
}

func (x ResourceTypeValue) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ResourceTypeValue.Descriptor instead.
func (ResourceTypeValue) EnumDescriptor() ([]byte, []int) {
	return file_hub_v1_hub_proto_rawDescGZIP(), []int{8}
}

// RelationType represents the type of relationship between resources.
type RelationType int32

const (
	RelationType_RELATION_TYPE_UNSPECIFIED RelationType = 0
	// Hierarchical relations
	RelationType_RELATION_TYPE_MEMBER_OF  RelationType = 1
	RelationType_RELATION_TYPE_HAS_MEMBER RelationType = 2
	RelationType_RELATION_TYPE_PART_OF    RelationType = 3
	RelationType_RELATION_TYPE_HAS_PART   RelationType = 4
	// Version relations
	RelationType_RELATION_TYPE_VERSION_OF     RelationType = 5
	RelationType_RELATION_TYPE_HAS_VERSION    RelationType = 6
	RelationType_RELATION_TYPE_REPLACES       RelationType = 7
	RelationType_RELATION_TYPE_IS_REPLACED_BY RelationType = 8
	// Format relations
	RelationType_RELATION_TYPE_FORMAT_OF  RelationType = 9
	RelationType_RELATION_TYPE_HAS_FORMAT RelationType = 10
	// Citation relations
	RelationType_RELATION_TYPE_REFERENCES  RelationType = 11
	RelationType_RELATION_TYPE_IS_CITED_BY RelationType = 12
	RelationType_RELATION_TYPE_CITES       RelationType = 13
	// Derivation relations
	RelationType_RELATION_TYPE_DERIVED_FROM RelationType = 14
	RelationType_RELATION_TYPE_SOURCE_OF    RelationType = 15
	RelationType_RELATION_TYPE_BASED_ON     RelationType = 16
	RelationType_RELATION_TYPE_IS_BASIS_FOR RelationType = 17
	// Supplementary relations
	RelationType_RELATION_TYPE_SUPPLEMENTS      RelationType = 18
	RelationType_RELATION_TYPE_IS_SUPPLEMENT_TO RelationType = 19
	RelationType_RELATION_TYPE_DOCUMENTS        RelationType = 20
	RelationType_RELATION_TYPE_IS_DOCUMENTED_BY RelationType = 21
	// Descriptive relations
	RelationType_RELATION_TYPE_DESCRIBES       RelationType = 22
	RelationType_RELATION_TYPE_IS_DESCRIBED_BY RelationType = 23
	// Identity relations
	RelationType_RELATION_TYPE_IDENTICAL_TO RelationType = 24
	RelationType_RELATION_TYPE_SAME_AS      RelationType = 25
	// Series relations
	RelationType_RELATION_TYPE_SERIES_OF RelationType = 26
	RelationType_RELATION_TYPE_IN_SERIES RelationType = 27
	// Generic
	RelationType_RELATION_TYPE_RELATED_TO RelationType = 28
	RelationType_RELATION_TYPE_OTHER      RelationType = 29
	// Supplementary (additional to 18-19)
	RelationType_RELATION_TYPE_SUPPLEMENTED_BY RelationType = 30 // Has supplementary material
	// Requirements
	RelationType_RELATION_TYPE_REQUIRED_BY RelationType = 31 // Is required by another resource
	RelationType_RELATION_TYPE_REQUIRES    RelationType = 32 // Requires another resource
	// Reviews
	RelationType_RELATION_TYPE_REVIEWS RelationType = 33 // Reviews another resource
)

// Enum value maps for RelationType.
var (
	RelationType_name = map[int32]string{
		0:  "RELATION_TYPE_UNSPECIFIED",
		1:  "RELATION_TYPE_MEMBER_OF",
		2:  "RELATION_TYPE_HAS_MEMBER",
		3:  "RELATION_TYPE_PART_OF",
		4:  "RELATION_TYPE_HAS_PART",
		5:  "RELATION_TYPE_VERSION_OF",
		6:  "RELATION_TYPE_HAS_VERSION",
		7:  "RELATION_TYPE_REPLACES",
		8:  "RELATION_TYPE_IS_REPLACED_BY",
		9:  "RELATION_TYPE_FORMAT_OF",
		10: "RELATION_TYPE_HAS_FORMAT",
		11: "RELATION_TYPE_REFERENCES",
		12: "RELATION_TYPE_IS_CITED_BY",
		13: "RELATION_TYPE_CITES",
		14: "RELATION_TYPE_DERIVED_FROM",
		15: "RELATION_TYPE_SOURCE_OF",
		16: "RELATION_TYPE_BASED_ON",
		17: "RELATION_TYPE_IS_BASIS_FOR",
		18: "RELATION_TYPE_SUPPLEMENTS",
		19: "RELATION_TYPE_IS_SUPPLEMENT_TO",
		20: "RELATION_TYPE_DOCUMENTS",
		21: "RELATION_TYPE_IS_DOCUMENTED_BY",
		22: "RELATION_TYPE_DESCRIBES",
		23: "RELATION_TYPE_IS_DESCRIBED_BY",
		24: "RELATION_TYPE_IDENTICAL_TO",
		25: "RELATION_TYPE_SAME_AS",
		26: "RELATION_TYPE_SERIES_OF",
		27: "RELATION_TYPE_IN_SERIES",
		28: "RELATION_TYPE_RELATED_TO",
		29: "RELATION_TYPE_OTHER",
		30: "RELATION_TYPE_SUPPLEMENTED_BY",
		31: "RELATION_TYPE_REQUIRED_BY",
		32: "RELATION_TYPE_REQUIRES",
		33: "RELATION_TYPE_REVIEWS",
	}
	RelationType_value = map[string]int32{
		"RELATION_TYPE_UNSPECIFIED":      0,
		"RELATION_TYPE_MEMBER_OF":        1,
		"RELATION_TYPE_HAS_MEMBER":       2,
		"RELATION_TYPE_PART_OF":          3,
		"RELATION_TYPE_HAS_PART":         4,
		"RELATION_TYPE_VERSION_OF":       5,
		"RELATION_TYPE_HAS_VERSION":      6,
		"RELATION_TYPE_REPLACES":         7,
		"RELATION_TYPE_IS_REPLACED_BY":   8,
		"RELATION_TYPE_FORMAT_OF":        9,
		"RELATION_TYPE_HAS_FORMAT":       10,
		"RELATION_TYPE_REFERENCES":       11,
		"RELATION_TYPE_IS_CITED_BY":      12,
		"RELATION_TYPE_CITES":            13,
		"RELATION_TYPE_DERIVED_FROM":     14,
		"RELATION_TYPE_SOURCE_OF":        15,
		"RELATION_TYPE_BASED_ON":         16,
		"RELATION_TYPE_IS_BASIS_FOR":     17,
		"RELATION_TYPE_SUPPLEMENTS":      18,
		"RELATION_TYPE_IS_SUPPLEMENT_TO": 19,
		"RELATION_TYPE_DOCUMENTS":        20,
		"RELATION_TYPE_IS_DOCUMENTED_BY": 21,
		"RELATION_TYPE_DESCRIBES":        22,
		"RELATION_TYPE_IS_DESCRIBED_BY":  23,
		"RELATION_TYPE_IDENTICAL_TO":     24,
		"RELATION_TYPE_SAME_AS":          25,
		"RELATION_TYPE_SERIES_OF":        26,
		"RELATION_TYPE_IN_SERIES":        27,
		"RELATION_TYPE_RELATED_TO":       28,
		"RELATION_TYPE_OTHER":            29,
		"RELATION_TYPE_SUPPLEMENTED_BY":  30,
		"RELATION_TYPE_REQUIRED_BY":      31,
		"RELATION_TYPE_REQUIRES":         32,
		"RELATION_TYPE_REVIEWS":          33,
	}
)

func (x RelationType) Enum() *RelationType {
	p := new(RelationType)
	*p = x
	return p
}

func (x RelationType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (RelationType) Descriptor() protoreflect.EnumDescriptor {
	return file_hub_v1_hub_proto_enumTypes[9].Descriptor()
}

func (RelationType) Type() protoreflect.EnumType {
	return &file_hub_v1_hub_proto_enumTypes[9]
}

func (x RelationType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use RelationType.Descriptor instead.
func (RelationType) EnumDescriptor() ([]byte, []int) {
	return file_hub_v1_hub_proto_rawDescGZIP(), []int{9}
}

// Record represents a single scholarly work with its metadata.
// This is the central type of the hub - all formats convert to/from this.
type Record struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Core metadata
	Title    string   `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	AltTitle []string `protobuf:"bytes,2,rep,name=alt_title,json=altTitle,proto3" json:"alt_title,omitempty"`
	Abstract string   `protobuf:"bytes,3,opt,name=abstract,proto3" json:"abstract,omitempty"`
	// Contributors (authors, editors, etc.)
	Contributors []*Contributor `protobuf:"bytes,4,rep,name=contributors,proto3" json:"contributors,omitempty"`
	// Dates with semantic types
	Dates []*DateValue `protobuf:"bytes,5,rep,name=dates,proto3" json:"dates,omitempty"`
	// Resource classification
	ResourceType *ResourceType `protobuf:"bytes,6,opt,name=resource_type,json=resourceType,proto3" json:"resource_type,omitempty"`
	Genres       []*Subject    `protobuf:"bytes,7,rep,name=genres,proto3" json:"genres,omitempty"`
	// Subject access
	Subjects []*Subject `protobuf:"bytes,8,rep,name=subjects,proto3" json:"subjects,omitempty"`
	Language string     `protobuf:"bytes,9,opt,name=language,proto3" json:"language,omitempty"`
	// Publication info
	Publisher      string              `protobuf:"bytes,10,opt,name=publisher,proto3" json:"publisher,omitempty"`
	PlacePublished string              `protobuf:"bytes,11,opt,name=place_published,json=placePublished,proto3" json:"place_published,omitempty"`
	Publication    *PublicationDetails `protobuf:"bytes,24,opt,name=publication,proto3" json:"publication,omitempty"`
	// Rights and access
	Rights          []*Rights `protobuf:"bytes,12,rep,name=rights,proto3" json:"rights,omitempty"`
	IsPublic        bool      `protobuf:"varint,25,opt,name=is_public,json=isPublic,proto3" json:"is_public,omitempty"`
	AccessCondition string    `protobuf:"bytes,26,opt,name=access_condition,json=accessCondition,proto3" json:"access_condition,omitempty"`
	// Identifiers
	Identifiers []*Identifier `protobuf:"bytes,13,rep,name=identifiers,proto3" json:"identifiers,omitempty"`
	// Descriptions and notes
	Description       string   `protobuf:"bytes,14,opt,name=description,proto3" json:"description,omitempty"`
	PhysicalDesc      string   `protobuf:"bytes,15,opt,name=physical_desc,json=physicalDesc,proto3" json:"physical_desc,omitempty"`
	Notes             []string `protobuf:"bytes,16,rep,name=notes,proto3" json:"notes,omitempty"`
	TableOfContents   string   `protobuf:"bytes,17,opt,name=table_of_contents,json=tableOfContents,proto3" json:"table_of_contents,omitempty"`
	Source            string   `protobuf:"bytes,18,opt,name=source,proto3" json:"source,omitempty"`
	DigitalOrigin     string   `protobuf:"bytes,19,opt,name=digital_origin,json=digitalOrigin,proto3" json:"digital_origin,omitempty"`
	Edition           string   `protobuf:"bytes,27,opt,name=edition,proto3" json:"edition,omitempty"`
	Version           string   `protobuf:"bytes,28,opt,name=version,proto3" json:"version,omitempty"`
	PreferredCitation string   `protobuf:"bytes,29,opt,name=preferred_citation,json=preferredCitation,proto3" json:"preferred_citation,omitempty"`
	// Technical Metadata
	ObjectModel   string `protobuf:"bytes,30,opt,name=object_model,json=objectModel,proto3" json:"object_model,omitempty"`
	AddCoverpage  bool   `protobuf:"varint,31,opt,name=add_coverpage,json=addCoverpage,proto3" json:"add_coverpage,omitempty"`
	CaptureDevice string `protobuf:"bytes,32,opt,name=capture_device,json=captureDevice,proto3" json:"capture_device,omitempty"`
	Ppi           int32  `protobuf:"varint,33,opt,name=ppi,proto3" json:"ppi,omitempty"`
	// Physical description details
	PageCount  int32  `protobuf:"varint,34,opt,name=page_count,json=pageCount,proto3" json:"page_count,omitempty"`
	Dimensions string `protobuf:"bytes,35,opt,name=dimensions,proto3" json:"dimensions,omitempty"`
	Duration   string `protobuf:"bytes,36,opt,name=duration,proto3" json:"duration,omitempty"`
	// Archival info
	ArchivalLocation *ArchivalLocation `protobuf:"bytes,37,opt,name=archival_location,json=archivalLocation,proto3" json:"archival_location,omitempty"`
	// Files
	Files []*File `protobuf:"bytes,38,rep,name=files,proto3" json:"files,omitempty"`
	// Physical form (e.g. Getty AAT)
	PhysicalForm []*Subject `protobuf:"bytes,39,rep,name=physical_form,json=physicalForm,proto3" json:"physical_form,omitempty"`
	// Relations to other works
	Relations []*Relation `protobuf:"bytes,20,rep,name=relations,proto3" json:"relations,omitempty"`
	// Thesis/dissertation specific
	DegreeInfo *DegreeInfo `protobuf:"bytes,21,opt,name=degree_info,json=degreeInfo,proto3" json:"degree_info,omitempty"`
	// Funding information
	Funders []*Funder `protobuf:"bytes,40,rep,name=funders,proto3" json:"funders,omitempty"`
	// Full title (when different from display title)
	FullTitle string `protobuf:"bytes,41,opt,name=full_title,json=fullTitle,proto3" json:"full_title,omitempty"`
	// Related departments/units (for non-thesis items like faculty publications)
	Departments []string `protobuf:"bytes,42,rep,name=departments,proto3" json:"departments,omitempty"`
	// Local access restrictions beyond rights statements
	LocalRestriction string `protobuf:"bytes,43,opt,name=local_restriction,json=localRestriction,proto3" json:"local_restriction,omitempty"`
	// Structured geographic location
	Geographic *HierarchicalGeographic `protobuf:"bytes,44,opt,name=geographic,proto3" json:"geographic,omitempty"`
	// Extra holds additional fields that don't map to standard Hub fields.
	// Used for round-trip preservation and format-specific data.
	//
	//  1. This is a TEMPORARY home - if a field appears in >50% of records,
	//     promote it to a first-class field in the Hub schema.
	//  2. Enforce consistent types - don't let spokes mix string "10" and int 10.
	//  3. Use machine names as keys (dc_creator), never human labels ("Creator").
	//  4. Data here is NOT indexed/searchable - only use for pass-through.
	//  5. Store semantics, not presentation (ISO dates, not "March 15, 2024").
	//
	// Periodic audit: Run `crosswalk audit-extras` to find promotion candidates.
	Extra *structpb.Struct `protobuf:"bytes,22,opt,name=extra,proto3" json:"extra,omitempty"`
	// Source metadata - tracks where this record came from for auditing.
	SourceInfo    *SourceInfo `protobuf:"bytes,23,opt,name=source_info,json=sourceInfo,proto3" json:"source_info,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Record) Reset() {
	*x = Record{}
	mi := &file_hub_v1_hub_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Record) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Record) ProtoMessage() {}

func (x *Record) ProtoReflect() protoreflect.Message {
	mi := &file_hub_v1_hub_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Record.ProtoReflect.Descriptor instead.
func (*Record) Descriptor() ([]byte, []int) {
	return file_hub_v1_hub_proto_rawDescGZIP(), []int{0}
}

func (x *Record) GetTitle() string {
	if x != nil {
		return x.Title
	}
	return ""
}

func (x *Record) GetAltTitle() []string {
	if x != nil {
		return x.AltTitle
	}
	return nil
}

func (x *Record) GetAbstract() string {
	if x != nil {
		return x.Abstract
	}
	return ""
}

func (x *Record) GetContributors() []*Contributor {
	if x != nil {
		return x.Contributors
	}
	return nil
}

func (x *Record) GetDates() []*DateValue {
	if x != nil {
		return x.Dates
	}
	return nil
}

func (x *Record) GetResourceType() *ResourceType {
	if x != nil {
		return x.ResourceType
	}
	return nil
}

func (x *Record) GetGenres() []*Subject {
	if x != nil {
		return x.Genres
	}
	return nil
}

func (x *Record) GetSubjects() []*Subject {
	if x != nil {
		return x.Subjects
	}
	return nil
}

func (x *Record) GetLanguage() string {
	if x != nil {
		return x.Language
	}
	return ""
}

func (x *Record) GetPublisher() string {
	if x != nil {
		return x.Publisher
	}
	return ""
}

func (x *Record) GetPlacePublished() string {
	if x != nil {
		return x.PlacePublished
	}
	return ""
}

func (x *Record) GetPublication() *PublicationDetails {
	if x != nil {
		return x.Publication
	}
	return nil
}

func (x *Record) GetRights() []*Rights {
	if x != nil {
		return x.Rights
	}
	return nil
}

func (x *Record) GetIsPublic() bool {
	if x != nil {
		return x.IsPublic
	}
	return false
}

func (x *Record) GetAccessCondition() string {
	if x != nil {
		return x.AccessCondition
	}
	return ""
}

func (x *Record) GetIdentifiers() []*Identifier {
	if x != nil {
		return x.Identifiers
	}
	return nil
}

func (x *Record) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *Record) GetPhysicalDesc() string {
	if x != nil {
		return x.PhysicalDesc
	}
	return ""
}

func (x *Record) GetNotes() []string {
	if x != nil {
		return x.Notes
	}
	return nil
}

func (x *Record) GetTableOfContents() string {
	if x != nil {
		return x.TableOfContents
	}
	return ""
}

func (x *Record) GetSource() string {
	if x != nil {
		return x.Source
	}
	return ""
}

func (x *Record) GetDigitalOrigin() string {
	if x != nil {
		return x.DigitalOrigin
	}
	return ""
}

func (x *Record) GetEdition() string {
	if x != nil {
		return x.Edition
	}
	return ""
}

func (x *Record) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *Record) GetPreferredCitation() string {
	if x != nil {
		return x.PreferredCitation
	}
	return ""
}

func (x *Record) GetObjectModel() string {
	if x != nil {
		return x.ObjectModel
	}
	return ""
}

func (x *Record) GetAddCoverpage() bool {
	if x != nil {
		return x.AddCoverpage
	}
	return false
}

func (x *Record) GetCaptureDevice() string {
	if x != nil {
		return x.CaptureDevice
	}
	return ""
}

func (x *Record) GetPpi() int32 {
	if x != nil {
		return x.Ppi
	}
	return 0
}

func (x *Record) GetPageCount() int32 {
	if x != nil {
		return x.PageCount
	}
	return 0
}

func (x *Record) GetDimensions() string {
	if x != nil {
		return x.Dimensions
	}
	return ""
}

func (x *Record) GetDuration() string {
	if x != nil {
		return x.Duration
	}
	return ""
}

func (x *Record) GetArchivalLocation() *ArchivalLocation {
	if x != nil {
		return x.ArchivalLocation
	}
	return nil
}

func (x *Record) GetFiles() []*File {
	if x != nil {
		return x.Files
	}
	return nil
}

func (x *Record) GetPhysicalForm() []*Subject {
	if x != nil {
		return x.PhysicalForm
	}
	return nil
}

func (x *Record) GetRelations() []*Relation {
	if x != nil {
		return x.Relations
	}
	return nil
}

func (x *Record) GetDegreeInfo() *DegreeInfo {
	if x != nil {
		return x.DegreeInfo
	}
	return nil
}

func (x *Record) GetFunders() []*Funder {
	if x != nil {
		return x.Funders
	}
	return nil
}

func (x *Record) GetFullTitle() string {
	if x != nil {
		return x.FullTitle
	}
	return ""
}

func (x *Record) GetDepartments() []string {
	if x != nil {
		return x.Departments
	}
	return nil
}

func (x *Record) GetLocalRestriction() string {
	if x != nil {
		return x.LocalRestriction
	}
	return ""
}

func (x *Record) GetGeographic() *HierarchicalGeographic {
	if x != nil {
		return x.Geographic
	}
	return nil
}

func (x *Record) GetExtra() *structpb.Struct {
	if x != nil {
		return x.Extra
	}
	return nil
}

func (x *Record) GetSourceInfo() *SourceInfo {
	if x != nil {
		return x.SourceInfo
	}
	return nil
}

// SourceInfo tracks the origin of a record for auditing and debugging.
type SourceInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Format name (e.g., "drupal", "csv", "datacite")
	Format string `protobuf:"bytes,1,opt,name=format,proto3" json:"format,omitempty"`
	// Format version if applicable (e.g., "5.3.1" for CrossRef)
	FormatVersion string `protobuf:"bytes,2,opt,name=format_version,json=formatVersion,proto3" json:"format_version,omitempty"`
	// Original identifier in source system
	SourceId string `protobuf:"bytes,3,opt,name=source_id,json=sourceId,proto3" json:"source_id,omitempty"`
	// Timestamp when parsed into Hub format
	ParsedAt *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=parsed_at,json=parsedAt,proto3" json:"parsed_at,omitempty"`
	// Profile used for parsing (if any)
	Profile string `protobuf:"bytes,5,opt,name=profile,proto3" json:"profile,omitempty"`
	// Fields that were placed in 'extra' (for audit purposes)
	UnmappedFields []string `protobuf:"bytes,6,rep,name=unmapped_fields,json=unmappedFields,proto3" json:"unmapped_fields,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *SourceInfo) Reset() {
	*x = SourceInfo{}
	mi := &file_hub_v1_hub_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SourceInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SourceInfo) ProtoMessage() {}

func (x *SourceInfo) ProtoReflect() protoreflect.Message {
	mi := &file_hub_v1_hub_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SourceInfo.ProtoReflect.Descriptor instead.
func (*SourceInfo) Descriptor() ([]byte, []int) {
	return file_hub_v1_hub_proto_rawDescGZIP(), []int{1}
}

func (x *SourceInfo) GetFormat() string {
	if x != nil {
		return x.Format
	}
	return ""
}

func (x *SourceInfo) GetFormatVersion() string {
	if x != nil {
		return x.FormatVersion
	}
	return ""
}

func (x *SourceInfo) GetSourceId() string {
	if x != nil {
		return x.SourceId
	}
	return ""
}

func (x *SourceInfo) GetParsedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.ParsedAt
	}
	return nil
}

func (x *SourceInfo) GetProfile() string {
	if x != nil {
		return x.Profile
	}
	return ""
}

func (x *SourceInfo) GetUnmappedFields() []string {
	if x != nil {
		return x.UnmappedFields
	}
	return nil
}

// Group represents a container with child records.
// Used for hierarchical outputs like CrossRef XML (issue + articles).
type Group struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Type          GroupType              `protobuf:"varint,1,opt,name=type,proto3,enum=hub.v1.GroupType" json:"type,omitempty"`
	Container     *Record                `protobuf:"bytes,2,opt,name=container,proto3" json:"container,omitempty"` // Parent record (e.g., journal issue)
	Members       []*Record              `protobuf:"bytes,3,rep,name=members,proto3" json:"members,omitempty"`     // Child records (e.g., articles)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Group) Reset() {
	*x = Group{}
	mi := &file_hub_v1_hub_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Group) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Group) ProtoMessage() {}

func (x *Group) ProtoReflect() protoreflect.Message {
	mi := &file_hub_v1_hub_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Group.ProtoReflect.Descriptor instead.
func (*Group) Descriptor() ([]byte, []int) {
	return file_hub_v1_hub_proto_rawDescGZIP(), []int{2}
}

func (x *Group) GetType() GroupType {
	if x != nil {
		return x.Type
	}
	return GroupType_GROUP_TYPE_UNSPECIFIED
}

func (x *Group) GetContainer() *Record {
	if x != nil {
		return x.Container
	}
	return nil
}

func (x *Group) GetMembers() []*Record {
	if x != nil {
		return x.Members
	}
	return nil
}

// Contributor represents a person or organization that contributed to a work.
type Contributor struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Name is the full name as a single string (e.g., "Fries, Albert F. Jr.")
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// ParsedName contains parsed name components if available
	ParsedName *ParsedName `protobuf:"bytes,2,opt,name=parsed_name,json=parsedName,proto3" json:"parsed_name,omitempty"`
	// Role is the contributor's role (e.g., "creator", "author", "editor")
	Role string `protobuf:"bytes,3,opt,name=role,proto3" json:"role,omitempty"`
	// RoleCode is the original role code (e.g., "relators:cre")
	RoleCode string `protobuf:"bytes,4,opt,name=role_code,json=roleCode,proto3" json:"role_code,omitempty"`
	// Type indicates whether this is a person or organization
	Type ContributorType `protobuf:"varint,5,opt,name=type,proto3,enum=hub.v1.ContributorType" json:"type,omitempty"`
	// Identifiers for the contributor (ORCID, ISNI, etc.)
	Identifiers []*Identifier `protobuf:"bytes,6,rep,name=identifiers,proto3" json:"identifiers,omitempty"`
	// Affiliation is the contributor's institutional affiliation (deprecated, use affiliations)
	Affiliation string `protobuf:"bytes,7,opt,name=affiliation,proto3" json:"affiliation,omitempty"`
	// SourceID is the original ID from the source system
	SourceId string `protobuf:"bytes,8,opt,name=source_id,json=sourceId,proto3" json:"source_id,omitempty"`
	// Affiliations for the contributor (preferred over single affiliation field)
	Affiliations  []*Affiliation `protobuf:"bytes,9,rep,name=affiliations,proto3" json:"affiliations,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Contributor) Reset() {
	*x = Contributor{}
	mi := &file_hub_v1_hub_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Contributor) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Contributor) ProtoMessage() {}

func (x *Contributor) ProtoReflect() protoreflect.Message {
	mi := &file_hub_v1_hub_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Contributor.ProtoReflect.Descriptor instead.
func (*Contributor) Descriptor() ([]byte, []int) {
	return file_hub_v1_hub_proto_rawDescGZIP(), []int{3}
}

func (x *Contributor) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Contributor) GetParsedName() *ParsedName {
	if x != nil {
		return x.ParsedName
	}
	return nil
}

func (x *Contributor) GetRole() string {
	if x != nil {
		return x.Role
	}
	return ""
}

func (x *Contributor) GetRoleCode() string {
	if x != nil {
		return x.RoleCode
	}
	return ""
}

func (x *Contributor) GetType() ContributorType {
	if x != nil {
		return x.Type
	}
	return ContributorType_CONTRIBUTOR_TYPE_UNSPECIFIED
}

func (x *Contributor) GetIdentifiers() []*Identifier {
	if x != nil {
		return x.Identifiers
	}
	return nil
}

func (x *Contributor) GetAffiliation() string {
	if x != nil {
		return x.Affiliation
	}
	return ""
}

func (x *Contributor) GetSourceId() string {
	if x != nil {
		return x.SourceId
	}
	return ""
}

func (x *Contributor) GetAffiliations() []*Affiliation {
	if x != nil {
		return x.Affiliations
	}
	return nil
}

// ParsedName contains parsed components of a personal name.
type ParsedName struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Family        string                 `protobuf:"bytes,1,opt,name=family,proto3" json:"family,omitempty"`                     // Last name / surname
	Given         string                 `protobuf:"bytes,2,opt,name=given,proto3" json:"given,omitempty"`                       // First name(s)
	Middle        string                 `protobuf:"bytes,3,opt,name=middle,proto3" json:"middle,omitempty"`                     // Middle name(s) or initial(s)
	Suffix        string                 `protobuf:"bytes,4,opt,name=suffix,proto3" json:"suffix,omitempty"`                     // Jr., Sr., III, etc.
	Prefix        string                 `protobuf:"bytes,5,opt,name=prefix,proto3" json:"prefix,omitempty"`                     // von, van, de, etc.
	FullName      string                 `protobuf:"bytes,6,opt,name=full_name,json=fullName,proto3" json:"full_name,omitempty"` // Original full name string
	Normalized    string                 `protobuf:"bytes,7,opt,name=normalized,proto3" json:"normalized,omitempty"`             // Normalized form: "Family, Given Middle Suffix"
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ParsedName) Reset() {
	*x = ParsedName{}
	mi := &file_hub_v1_hub_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ParsedName) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ParsedName) ProtoMessage() {}

func (x *ParsedName) ProtoReflect() protoreflect.Message {
	mi := &file_hub_v1_hub_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ParsedName.ProtoReflect.Descriptor instead.
func (*ParsedName) Descriptor() ([]byte, []int) {
	return file_hub_v1_hub_proto_rawDescGZIP(), []int{4}
}

func (x *ParsedName) GetFamily() string {
	if x != nil {
		return x.Family
	}
	return ""
}

func (x *ParsedName) GetGiven() string {
	if x != nil {
		return x.Given
	}
	return ""
}

func (x *ParsedName) GetMiddle() string {
	if x != nil {
		return x.Middle
	}
	return ""
}

func (x *ParsedName) GetSuffix() string {
	if x != nil {
		return x.Suffix
	}
	return ""
}

func (x *ParsedName) GetPrefix() string {
	if x != nil {
		return x.Prefix
	}
	return ""
}

func (x *ParsedName) GetFullName() string {
	if x != nil {
		return x.FullName
	}
	return ""
}

func (x *ParsedName) GetNormalized() string {
	if x != nil {
		return x.Normalized
	}
	return ""
}

// DateValue represents a date with varying levels of precision and uncertainty.
// Supports EDTF (Extended Date/Time Format) concepts.
type DateValue struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Type indicates the semantic meaning of this date
	Type DateType `protobuf:"varint,1,opt,name=type,proto3,enum=hub.v1.DateType" json:"type,omitempty"`
	// Raw is the original date string as provided
	Raw string `protobuf:"bytes,2,opt,name=raw,proto3" json:"raw,omitempty"`
	// Year, Month, Day represent the parsed date components
	Year  int32 `protobuf:"varint,3,opt,name=year,proto3" json:"year,omitempty"`
	Month int32 `protobuf:"varint,4,opt,name=month,proto3" json:"month,omitempty"` // 1-12, or 0 if unspecified
	Day   int32 `protobuf:"varint,5,opt,name=day,proto3" json:"day,omitempty"`     // 1-31, or 0 if unspecified
	// End date for ranges/intervals
	EndYear  int32 `protobuf:"varint,6,opt,name=end_year,json=endYear,proto3" json:"end_year,omitempty"`
	EndMonth int32 `protobuf:"varint,7,opt,name=end_month,json=endMonth,proto3" json:"end_month,omitempty"`
	EndDay   int32 `protobuf:"varint,8,opt,name=end_day,json=endDay,proto3" json:"end_day,omitempty"`
	// Precision indicates how specific the date is
	Precision DatePrecision `protobuf:"varint,9,opt,name=precision,proto3,enum=hub.v1.DatePrecision" json:"precision,omitempty"`
	// Qualifier indicates uncertainty or approximation
	Qualifier DateQualifier `protobuf:"varint,10,opt,name=qualifier,proto3,enum=hub.v1.DateQualifier" json:"qualifier,omitempty"`
	// IsRange indicates this is a date range
	IsRange bool `protobuf:"varint,11,opt,name=is_range,json=isRange,proto3" json:"is_range,omitempty"`
	// Time component if available
	Time *timestamppb.Timestamp `protobuf:"bytes,12,opt,name=time,proto3" json:"time,omitempty"`
	// Season (e.g., "Spring", "Winter")
	Season        string `protobuf:"bytes,13,opt,name=season,proto3" json:"season,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DateValue) Reset() {
	*x = DateValue{}
	mi := &file_hub_v1_hub_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DateValue) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DateValue) ProtoMessage() {}

func (x *DateValue) ProtoReflect() protoreflect.Message {
	mi := &file_hub_v1_hub_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DateValue.ProtoReflect.Descriptor instead.
func (*DateValue) Descriptor() ([]byte, []int) {
	return file_hub_v1_hub_proto_rawDescGZIP(), []int{5}
}

func (x *DateValue) GetType() DateType {
	if x != nil {
		return x.Type
	}
	return DateType_DATE_TYPE_UNSPECIFIED
}

func (x *DateValue) GetRaw() string {
	if x != nil {
		return x.Raw
	}
	return ""
}

func (x *DateValue) GetYear() int32 {
	if x != nil {
		return x.Year
	}
	return 0
}

func (x *DateValue) GetMonth() int32 {
	if x != nil {
		return x.Month
	}
	return 0
}

func (x *DateValue) GetDay() int32 {
	if x != nil {
		return x.Day
	}
	return 0
}

func (x *DateValue) GetEndYear() int32 {
	if x != nil {
		return x.EndYear
	}
	return 0
}

func (x *DateValue) GetEndMonth() int32 {
	if x != nil {
		return x.EndMonth
	}
	return 0
}

func (x *DateValue) GetEndDay() int32 {
	if x != nil {
		return x.EndDay
	}
	return 0
}

func (x *DateValue) GetPrecision() DatePrecision {
	if x != nil {
		return x.Precision
	}
	return DatePrecision_DATE_PRECISION_UNSPECIFIED
}

func (x *DateValue) GetQualifier() DateQualifier {
	if x != nil {
		return x.Qualifier
	}
	return DateQualifier_DATE_QUALIFIER_UNSPECIFIED
}

func (x *DateValue) GetIsRange() bool {
	if x != nil {
		return x.IsRange
	}
	return false
}

func (x *DateValue) GetTime() *timestamppb.Timestamp {
	if x != nil {
		return x.Time
	}
	return nil
}

func (x *DateValue) GetSeason() string {
	if x != nil {
		return x.Season
	}
	return ""
}

// Identifier represents a typed identifier for a scholarly work.
type Identifier struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Type          IdentifierType         `protobuf:"varint,1,opt,name=type,proto3,enum=hub.v1.IdentifierType" json:"type,omitempty"`
	Value         string                 `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	Display       string                 `protobuf:"bytes,3,opt,name=display,proto3" json:"display,omitempty"`                             // Optional human-readable display form
	IsPreferred   bool                   `protobuf:"varint,4,opt,name=is_preferred,json=isPreferred,proto3" json:"is_preferred,omitempty"` // Is this the preferred identifier of its type?
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Identifier) Reset() {
	*x = Identifier{}
	mi := &file_hub_v1_hub_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Identifier) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Identifier) ProtoMessage() {}

func (x *Identifier) ProtoReflect() protoreflect.Message {
	mi := &file_hub_v1_hub_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Identifier.ProtoReflect.Descriptor instead.
func (*Identifier) Descriptor() ([]byte, []int) {
	return file_hub_v1_hub_proto_rawDescGZIP(), []int{6}
}

func (x *Identifier) GetType() IdentifierType {
	if x != nil {
		return x.Type
	}
	return IdentifierType_IDENTIFIER_TYPE_UNSPECIFIED
}

func (x *Identifier) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

func (x *Identifier) GetDisplay() string {
	if x != nil {
		return x.Display
	}
	return ""
}

func (x *Identifier) GetIsPreferred() bool {
	if x != nil {
		return x.IsPreferred
	}
	return false
}

// Subject represents a subject, keyword, or topic classification.
type Subject struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Value         string                 `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	Vocabulary    SubjectVocabulary      `protobuf:"varint,2,opt,name=vocabulary,proto3,enum=hub.v1.SubjectVocabulary" json:"vocabulary,omitempty"`
	Uri           string                 `protobuf:"bytes,3,opt,name=uri,proto3" json:"uri,omitempty"`                           // Optional URI for the subject term
	SourceId      string                 `protobuf:"bytes,4,opt,name=source_id,json=sourceId,proto3" json:"source_id,omitempty"` // Original ID from the source system
	Type          SubjectType            `protobuf:"varint,5,opt,name=type,proto3,enum=hub.v1.SubjectType" json:"type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Subject) Reset() {
	*x = Subject{}
	mi := &file_hub_v1_hub_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Subject) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Subject) ProtoMessage() {}

func (x *Subject) ProtoReflect() protoreflect.Message {
	mi := &file_hub_v1_hub_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Subject.ProtoReflect.Descriptor instead.
func (*Subject) Descriptor() ([]byte, []int) {
	return file_hub_v1_hub_proto_rawDescGZIP(), []int{7}
}

func (x *Subject) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

func (x *Subject) GetVocabulary() SubjectVocabulary {
	if x != nil {
		return x.Vocabulary
	}
	return SubjectVocabulary_SUBJECT_VOCABULARY_UNSPECIFIED
}

func (x *Subject) GetUri() string {
	if x != nil {
		return x.Uri
	}
	return ""
}

func (x *Subject) GetSourceId() string {
	if x != nil {
		return x.SourceId
	}
	return ""
}

func (x *Subject) GetType() SubjectType {
	if x != nil {
		return x.Type
	}
	return SubjectType_SUBJECT_TYPE_UNSPECIFIED
}

// Rights represents rights information for a resource.
type Rights struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Statement     string                 `protobuf:"bytes,1,opt,name=statement,proto3" json:"statement,omitempty"` // Rights statement text
	Uri           string                 `protobuf:"bytes,2,opt,name=uri,proto3" json:"uri,omitempty"`             // URI for standardized rights statement
	License       string                 `protobuf:"bytes,3,opt,name=license,proto3" json:"license,omitempty"`     // License identifier (e.g., "CC-BY-4.0")
	Holder        string                 `protobuf:"bytes,4,opt,name=holder,proto3" json:"holder,omitempty"`       // Rights holder name
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Rights) Reset() {
	*x = Rights{}
	mi := &file_hub_v1_hub_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Rights) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Rights) ProtoMessage() {}

func (x *Rights) ProtoReflect() protoreflect.Message {
	mi := &file_hub_v1_hub_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Rights.ProtoReflect.Descriptor instead.
func (*Rights) Descriptor() ([]byte, []int) {
	return file_hub_v1_hub_proto_rawDescGZIP(), []int{8}
}

func (x *Rights) GetStatement() string {
	if x != nil {
		return x.Statement
	}
	return ""
}

func (x *Rights) GetUri() string {
	if x != nil {
		return x.Uri
	}
	return ""
}

func (x *Rights) GetLicense() string {
	if x != nil {
		return x.License
	}
	return ""
}

func (x *Rights) GetHolder() string {
	if x != nil {
		return x.Holder
	}
	return ""
}

// ResourceType represents the type of a scholarly resource.
type ResourceType struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Type          ResourceTypeValue      `protobuf:"varint,1,opt,name=type,proto3,enum=hub.v1.ResourceTypeValue" json:"type,omitempty"`
	Original      string                 `protobuf:"bytes,2,opt,name=original,proto3" json:"original,omitempty"`     // Original type string from the source
	Vocabulary    string                 `protobuf:"bytes,3,opt,name=vocabulary,proto3" json:"vocabulary,omitempty"` // Vocabulary the original type came from
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ResourceType) Reset() {
	*x = ResourceType{}
	mi := &file_hub_v1_hub_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ResourceType) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ResourceType) ProtoMessage() {}

func (x *ResourceType) ProtoReflect() protoreflect.Message {
	mi := &file_hub_v1_hub_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ResourceType.ProtoReflect.Descriptor instead.
func (*ResourceType) Descriptor() ([]byte, []int) {
	return file_hub_v1_hub_proto_rawDescGZIP(), []int{9}
}

func (x *ResourceType) GetType() ResourceTypeValue {
	if x != nil {
		return x.Type
	}
	return ResourceTypeValue_RESOURCE_TYPE_UNSPECIFIED
}

func (x *ResourceType) GetOriginal() string {
	if x != nil {
		return x.Original
	}
	return ""
}

func (x *ResourceType) GetVocabulary() string {
	if x != nil {
		return x.Vocabulary
	}
	return ""
}

// Relation represents a relationship between this record and another resource.
type Relation struct {
	state              protoimpl.MessageState `protogen:"open.v1"`
	Type               RelationType           `protobuf:"varint,1,opt,name=type,proto3,enum=hub.v1.RelationType" json:"type,omitempty"`
	TargetTitle        string                 `protobuf:"bytes,2,opt,name=target_title,json=targetTitle,proto3" json:"target_title,omitempty"`
	TargetId           string                 `protobuf:"bytes,3,opt,name=target_id,json=targetId,proto3" json:"target_id,omitempty"`
	TargetIdType       IdentifierType         `protobuf:"varint,4,opt,name=target_id_type,json=targetIdType,proto3,enum=hub.v1.IdentifierType" json:"target_id_type,omitempty"`
	TargetUri          string                 `protobuf:"bytes,5,opt,name=target_uri,json=targetUri,proto3" json:"target_uri,omitempty"`
	SourceId           string                 `protobuf:"bytes,6,opt,name=source_id,json=sourceId,proto3" json:"source_id,omitempty"`                                                                // Original ID from the source system
	Description        string                 `protobuf:"bytes,7,opt,name=description,proto3" json:"description,omitempty"`                                                                          // Additional context about the relationship
	TargetResourceType ResourceTypeValue      `protobuf:"varint,8,opt,name=target_resource_type,json=targetResourceType,proto3,enum=hub.v1.ResourceTypeValue" json:"target_resource_type,omitempty"` // Resource type of the target (e.g., COLLECTION)
	TargetTypeUri      string                 `protobuf:"bytes,9,opt,name=target_type_uri,json=targetTypeUri,proto3" json:"target_type_uri,omitempty"`                                               // External URI for target's type (e.g., "https://schema.org/Collection")
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *Relation) Reset() {
	*x = Relation{}
	mi := &file_hub_v1_hub_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Relation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Relation) ProtoMessage() {}

func (x *Relation) ProtoReflect() protoreflect.Message {
	mi := &file_hub_v1_hub_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Relation.ProtoReflect.Descriptor instead.
func (*Relation) Descriptor() ([]byte, []int) {
	return file_hub_v1_hub_proto_rawDescGZIP(), []int{10}
}

func (x *Relation) GetType() RelationType {
	if x != nil {
		return x.Type
	}
	return RelationType_RELATION_TYPE_UNSPECIFIED
}

func (x *Relation) GetTargetTitle() string {
	if x != nil {
		return x.TargetTitle
	}
	return ""
}

func (x *Relation) GetTargetId() string {
	if x != nil {
		return x.TargetId
	}
	return ""
}

func (x *Relation) GetTargetIdType() IdentifierType {
	if x != nil {
		return x.TargetIdType
	}
	return IdentifierType_IDENTIFIER_TYPE_UNSPECIFIED
}

func (x *Relation) GetTargetUri() string {
	if x != nil {
		return x.TargetUri
	}
	return ""
}

func (x *Relation) GetSourceId() string {
	if x != nil {
		return x.SourceId
	}
	return ""
}

func (x *Relation) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *Relation) GetTargetResourceType() ResourceTypeValue {
	if x != nil {
		return x.TargetResourceType
	}
	return ResourceTypeValue_RESOURCE_TYPE_UNSPECIFIED
}

func (x *Relation) GetTargetTypeUri() string {
	if x != nil {
		return x.TargetTypeUri
	}
	return ""
}

// DegreeInfo holds thesis/dissertation-specific metadata.
type DegreeInfo struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	DegreeName    string                 `protobuf:"bytes,1,opt,name=degree_name,json=degreeName,proto3" json:"degree_name,omitempty"`    // e.g., "Master of Science"
	DegreeLevel   string                 `protobuf:"bytes,2,opt,name=degree_level,json=degreeLevel,proto3" json:"degree_level,omitempty"` // e.g., "Masters", "Doctoral"
	Department    string                 `protobuf:"bytes,3,opt,name=department,proto3" json:"department,omitempty"`                      // Granting department
	Institution   string                 `protobuf:"bytes,4,opt,name=institution,proto3" json:"institution,omitempty"`                    // Granting institution
	Date          *DateValue             `protobuf:"bytes,5,opt,name=date,proto3" json:"date,omitempty"`                                  // Date degree was granted
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DegreeInfo) Reset() {
	*x = DegreeInfo{}
	mi := &file_hub_v1_hub_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DegreeInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DegreeInfo) ProtoMessage() {}

func (x *DegreeInfo) ProtoReflect() protoreflect.Message {
	mi := &file_hub_v1_hub_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DegreeInfo.ProtoReflect.Descriptor instead.
func (*DegreeInfo) Descriptor() ([]byte, []int) {
	return file_hub_v1_hub_proto_rawDescGZIP(), []int{11}
}

func (x *DegreeInfo) GetDegreeName() string {
	if x != nil {
		return x.DegreeName
	}
	return ""
}

func (x *DegreeInfo) GetDegreeLevel() string {
	if x != nil {
		return x.DegreeLevel
	}
	return ""
}

func (x *DegreeInfo) GetDepartment() string {
	if x != nil {
		return x.Department
	}
	return ""
}

func (x *DegreeInfo) GetInstitution() string {
	if x != nil {
		return x.Institution
	}
	return ""
}

func (x *DegreeInfo) GetDate() *DateValue {
	if x != nil {
		return x.Date
	}
	return nil
}

// Funder represents funding information for a resource.
type Funder struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	Name           string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`                                           // Funder name (e.g., "National Science Foundation")
	Identifier     string                 `protobuf:"bytes,2,opt,name=identifier,proto3" json:"identifier,omitempty"`                               // Funder identifier (e.g., Crossref Funder ID, ROR)
	IdentifierType string                 `protobuf:"bytes,3,opt,name=identifier_type,json=identifierType,proto3" json:"identifier_type,omitempty"` // Type of funder identifier
	AwardNumbers   []string               `protobuf:"bytes,4,rep,name=award_numbers,json=awardNumbers,proto3" json:"award_numbers,omitempty"`       // Grant/award numbers
	AwardTitle     string                 `protobuf:"bytes,5,opt,name=award_title,json=awardTitle,proto3" json:"award_title,omitempty"`             // Title of the funded project/award
	AwardUri       string                 `protobuf:"bytes,6,opt,name=award_uri,json=awardUri,proto3" json:"award_uri,omitempty"`                   // URI for the award
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *Funder) Reset() {
	*x = Funder{}
	mi := &file_hub_v1_hub_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Funder) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Funder) ProtoMessage() {}

func (x *Funder) ProtoReflect() protoreflect.Message {
	mi := &file_hub_v1_hub_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Funder.ProtoReflect.Descriptor instead.
func (*Funder) Descriptor() ([]byte, []int) {
	return file_hub_v1_hub_proto_rawDescGZIP(), []int{12}
}

func (x *Funder) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Funder) GetIdentifier() string {
	if x != nil {
		return x.Identifier
	}
	return ""
}

func (x *Funder) GetIdentifierType() string {
	if x != nil {
		return x.IdentifierType
	}
	return ""
}

func (x *Funder) GetAwardNumbers() []string {
	if x != nil {
		return x.AwardNumbers
	}
	return nil
}

func (x *Funder) GetAwardTitle() string {
	if x != nil {
		return x.AwardTitle
	}
	return ""
}

func (x *Funder) GetAwardUri() string {
	if x != nil {
		return x.AwardUri
	}
	return ""
}

// Affiliation represents an institutional affiliation for a contributor.
type Affiliation struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	Name           string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`                                           // Affiliation name
	Identifier     string                 `protobuf:"bytes,2,opt,name=identifier,proto3" json:"identifier,omitempty"`                               // Affiliation identifier (e.g., ROR)
	IdentifierType string                 `protobuf:"bytes,3,opt,name=identifier_type,json=identifierType,proto3" json:"identifier_type,omitempty"` // Type of identifier (e.g., "ROR", "ISNI")
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *Affiliation) Reset() {
	*x = Affiliation{}
	mi := &file_hub_v1_hub_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Affiliation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Affiliation) ProtoMessage() {}

func (x *Affiliation) ProtoReflect() protoreflect.Message {
	mi := &file_hub_v1_hub_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Affiliation.ProtoReflect.Descriptor instead.
func (*Affiliation) Descriptor() ([]byte, []int) {
	return file_hub_v1_hub_proto_rawDescGZIP(), []int{13}
}

func (x *Affiliation) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Affiliation) GetIdentifier() string {
	if x != nil {
		return x.Identifier
	}
	return ""
}

func (x *Affiliation) GetIdentifierType() string {
	if x != nil {
		return x.IdentifierType
	}
	return ""
}

// File represents a file associated with the record.
type File struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Path          string                 `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	Name          string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	MimeType      string                 `protobuf:"bytes,3,opt,name=mime_type,json=mimeType,proto3" json:"mime_type,omitempty"`
	SizeBytes     int64                  `protobuf:"varint,4,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	Description   string                 `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	Role          string                 `protobuf:"bytes,6,opt,name=role,proto3" json:"role,omitempty"` // e.g. "supplemental", "service", "thumbnail"
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *File) Reset() {
	*x = File{}
	mi := &file_hub_v1_hub_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *File) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*File) ProtoMessage() {}

func (x *File) ProtoReflect() protoreflect.Message {
	mi := &file_hub_v1_hub_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use File.ProtoReflect.Descriptor instead.
func (*File) Descriptor() ([]byte, []int) {
	return file_hub_v1_hub_proto_rawDescGZIP(), []int{14}
}

func (x *File) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

func (x *File) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *File) GetMimeType() string {
	if x != nil {
		return x.MimeType
	}
	return ""
}

func (x *File) GetSizeBytes() int64 {
	if x != nil {
		return x.SizeBytes
	}
	return 0
}

func (x *File) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *File) GetRole() string {
	if x != nil {
		return x.Role
	}
	return ""
}

// ArchivalLocation represents physical archival location.
type ArchivalLocation struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Collection    string                 `protobuf:"bytes,1,opt,name=collection,proto3" json:"collection,omitempty"`
	Series        string                 `protobuf:"bytes,2,opt,name=series,proto3" json:"series,omitempty"`
	Box           string                 `protobuf:"bytes,3,opt,name=box,proto3" json:"box,omitempty"`
	Folder        string                 `protobuf:"bytes,4,opt,name=folder,proto3" json:"folder,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ArchivalLocation) Reset() {
	*x = ArchivalLocation{}
	mi := &file_hub_v1_hub_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ArchivalLocation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ArchivalLocation) ProtoMessage() {}

func (x *ArchivalLocation) ProtoReflect() protoreflect.Message {
	mi := &file_hub_v1_hub_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ArchivalLocation.ProtoReflect.Descriptor instead.
func (*ArchivalLocation) Descriptor() ([]byte, []int) {
	return file_hub_v1_hub_proto_rawDescGZIP(), []int{15}
}

func (x *ArchivalLocation) GetCollection() string {
	if x != nil {
		return x.Collection
	}
	return ""
}

func (x *ArchivalLocation) GetSeries() string {
	if x != nil {
		return x.Series
	}
	return ""
}

func (x *ArchivalLocation) GetBox() string {
	if x != nil {
		return x.Box
	}
	return ""
}

func (x *ArchivalLocation) GetFolder() string {
	if x != nil {
		return x.Folder
	}
	return ""
}

// PublicationDetails holds specific publication metadata often found in citations.
type PublicationDetails struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Title         string                 `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"` // Container title
	Volume        string                 `protobuf:"bytes,2,opt,name=volume,proto3" json:"volume,omitempty"`
	Issue         string                 `protobuf:"bytes,3,opt,name=issue,proto3" json:"issue,omitempty"`
	Pages         string                 `protobuf:"bytes,4,opt,name=pages,proto3" json:"pages,omitempty"`
	Issn          string                 `protobuf:"bytes,5,opt,name=issn,proto3" json:"issn,omitempty"`
	LIssn         string                 `protobuf:"bytes,6,opt,name=l_issn,json=lIssn,proto3" json:"l_issn,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PublicationDetails) Reset() {
	*x = PublicationDetails{}
	mi := &file_hub_v1_hub_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PublicationDetails) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PublicationDetails) ProtoMessage() {}

func (x *PublicationDetails) ProtoReflect() protoreflect.Message {
	mi := &file_hub_v1_hub_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PublicationDetails.ProtoReflect.Descriptor instead.
func (*PublicationDetails) Descriptor() ([]byte, []int) {
	return file_hub_v1_hub_proto_rawDescGZIP(), []int{16}
}

func (x *PublicationDetails) GetTitle() string {
	if x != nil {
		return x.Title
	}
	return ""
}

func (x *PublicationDetails) GetVolume() string {
	if x != nil {
		return x.Volume
	}
	return ""
}

func (x *PublicationDetails) GetIssue() string {
	if x != nil {
		return x.Issue
	}
	return ""
}

func (x *PublicationDetails) GetPages() string {
	if x != nil {
		return x.Pages
	}
	return ""
}

func (x *PublicationDetails) GetIssn() string {
	if x != nil {
		return x.Issn
	}
	return ""
}

func (x *PublicationDetails) GetLIssn() string {
	if x != nil {
		return x.LIssn
	}
	return ""
}

// HierarchicalGeographic represents structured geographic location data.
// Used for geographic subjects in MODS and similar formats.
type HierarchicalGeographic struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Country       string                 `protobuf:"bytes,1,opt,name=country,proto3" json:"country,omitempty"`
	State         string                 `protobuf:"bytes,2,opt,name=state,proto3" json:"state,omitempty"` // State/province
	County        string                 `protobuf:"bytes,3,opt,name=county,proto3" json:"county,omitempty"`
	City          string                 `protobuf:"bytes,4,opt,name=city,proto3" json:"city,omitempty"`
	Area          string                 `protobuf:"bytes,5,opt,name=area,proto3" json:"area,omitempty"` // Neighborhood/area
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HierarchicalGeographic) Reset() {
	*x = HierarchicalGeographic{}
	mi := &file_hub_v1_hub_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HierarchicalGeographic) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HierarchicalGeographic) ProtoMessage() {}

func (x *HierarchicalGeographic) ProtoReflect() protoreflect.Message {
	mi := &file_hub_v1_hub_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HierarchicalGeographic.ProtoReflect.Descriptor instead.
func (*HierarchicalGeographic) Descriptor() ([]byte, []int) {
	return file_hub_v1_hub_proto_rawDescGZIP(), []int{17}
}

func (x *HierarchicalGeographic) GetCountry() string {
	if x != nil {
		return x.Country
	}
	return ""
}

func (x *HierarchicalGeographic) GetState() string {
	if x != nil {
		return x.State
	}
	return ""
}

func (x *HierarchicalGeographic) GetCounty() string {
	if x != nil {
		return x.County
	}
	return ""
}

func (x *HierarchicalGeographic) GetCity() string {
	if x != nil {
		return x.City
	}
	return ""
}

func (x *HierarchicalGeographic) GetArea() string {
	if x != nil {
		return x.Area
	}
	return ""
}

var File_hub_v1_hub_proto protoreflect.FileDescriptor

const file_hub_v1_hub_proto_rawDesc = "" +
	"\n" +
	"\x10hub/v1/hub.proto\x12\x06hub.v1\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1cgoogle/protobuf/struct.proto\"\xda\r\n" +
	"\x06Record\x12\x14\n" +
	"\x05title\x18\x01 \x01(\tR\x05title\x12\x1b\n" +
	"\talt_title\x18\x02 \x03(\tR\baltTitle\x12\x1a\n" +
	"\babstract\x18\x03 \x01(\tR\babstract\x127\n" +
	"\fcontributors\x18\x04 \x03(\v2\x13.hub.v1.ContributorR\fcontributors\x12'\n" +
	"\x05dates\x18\x05 \x03(\v2\x11.hub.v1.DateValueR\x05dates\x129\n" +
	"\rresource_type\x18\x06 \x01(\v2\x14.hub.v1.ResourceTypeR\fresourceType\x12'\n" +
	"\x06genres\x18\a \x03(\v2\x0f.hub.v1.SubjectR\x06genres\x12+\n" +
	"\bsubjects\x18\b \x03(\v2\x0f.hub.v1.SubjectR\bsubjects\x12\x1a\n" +
	"\blanguage\x18\t \x01(\tR\blanguage\x12\x1c\n" +
	"\tpublisher\x18\n" +
	" \x01(\tR\tpublisher\x12'\n" +
	"\x0fplace_published\x18\v \x01(\tR\x0eplacePublished\x12<\n" +
	"\vpublication\x18\x18 \x01(\v2\x1a.hub.v1.PublicationDetailsR\vpublication\x12&\n" +
	"\x06rights\x18\f \x03(\v2\x0e.hub.v1.RightsR\x06rights\x12\x1b\n" +
	"\tis_public\x18\x19 \x01(\bR\bisPublic\x12)\n" +
	"\x10access_condition\x18\x1a \x01(\tR\x0faccessCondition\x124\n" +
	"\videntifiers\x18\r \x03(\v2\x12.hub.v1.IdentifierR\videntifiers\x12 \n" +
	"\vdescription\x18\x0e \x01(\tR\vdescription\x12#\n" +
	"\rphysical_desc\x18\x0f \x01(\tR\fphysicalDesc\x12\x14\n" +
	"\x05notes\x18\x10 \x03(\tR\x05notes\x12*\n" +
	"\x11table_of_contents\x18\x11 \x01(\tR\x0ftableOfContents\x12\x16\n" +
	"\x06source\x18\x12 \x01(\tR\x06source\x12%\n" +
	"\x0edigital_origin\x18\x13 \x01(\tR\rdigitalOrigin\x12\x18\n" +
	"\aedition\x18\x1b \x01(\tR\aedition\x12\x18\n" +
	"\aversion\x18\x1c \x01(\tR\aversion\x12-\n" +
	"\x12preferred_citation\x18\x1d \x01(\tR\x11preferredCitation\x12!\n" +
	"\fobject_model\x18\x1e \x01(\tR\vobjectModel\x12#\n" +
	"\radd_coverpage\x18\x1f \x01(\bR\faddCoverpage\x12%\n" +
	"\x0ecapture_device\x18  \x01(\tR\rcaptureDevice\x12\x10\n" +
	"\x03ppi\x18! \x01(\x05R\x03ppi\x12\x1d\n" +
	"\n" +
	"page_count\x18\" \x01(\x05R\tpageCount\x12\x1e\n" +
	"\n" +
	"dimensions\x18# \x01(\tR\n" +
	"dimensions\x12\x1a\n" +
	"\bduration\x18$ \x01(\tR\bduration\x12E\n" +
	"\x11archival_location\x18% \x01(\v2\x18.hub.v1.ArchivalLocationR\x10archivalLocation\x12\"\n" +
	"\x05files\x18& \x03(\v2\f.hub.v1.FileR\x05files\x124\n" +
	"\rphysical_form\x18' \x03(\v2\x0f.hub.v1.SubjectR\fphysicalForm\x12.\n" +
	"\trelations\x18\x14 \x03(\v2\x10.hub.v1.RelationR\trelations\x123\n" +
	"\vdegree_info\x18\x15 \x01(\v2\x12.hub.v1.DegreeInfoR\n" +
	"degreeInfo\x12(\n" +
	"\afunders\x18( \x03(\v2\x0e.hub.v1.FunderR\afunders\x12\x1d\n" +
	"\n" +
	"full_title\x18) \x01(\tR\tfullTitle\x12 \n" +
	"\vdepartments\x18* \x03(\tR\vdepartments\x12+\n" +
	"\x11local_restriction\x18+ \x01(\tR\x10localRestriction\x12>\n" +
	"\n" +
	"geographic\x18, \x01(\v2\x1e.hub.v1.HierarchicalGeographicR\n" +
	"geographic\x12-\n" +
	"\x05extra\x18\x16 \x01(\v2\x17.google.protobuf.StructR\x05extra\x123\n" +
	"\vsource_info\x18\x17 \x01(\v2\x12.hub.v1.SourceInfoR\n" +
	"sourceInfo\"\xe4\x01\n" +
	"\n" +
	"SourceInfo\x12\x16\n" +
	"\x06format\x18\x01 \x01(\tR\x06format\x12%\n" +
	"\x0eformat_version\x18\x02 \x01(\tR\rformatVersion\x12\x1b\n" +
	"\tsource_id\x18\x03 \x01(\tR\bsourceId\x127\n" +
	"\tparsed_at\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampR\bparsedAt\x12\x18\n" +
	"\aprofile\x18\x05 \x01(\tR\aprofile\x12'\n" +
	"\x0funmapped_fields\x18\x06 \x03(\tR\x0eunmappedFields\"\x86\x01\n" +
	"\x05Group\x12%\n" +
	"\x04type\x18\x01 \x01(\x0e2\x11.hub.v1.GroupTypeR\x04type\x12,\n" +
	"\tcontainer\x18\x02 \x01(\v2\x0e.hub.v1.RecordR\tcontainer\x12(\n" +
	"\amembers\x18\x03 \x03(\v2\x0e.hub.v1.RecordR\amembers\"\xe2\x02\n" +
	"\vContributor\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x123\n" +
	"\vparsed_name\x18\x02 \x01(\v2\x12.hub.v1.ParsedNameR\n" +
	"parsedName\x12\x12\n" +
	"\x04role\x18\x03 \x01(\tR\x04role\x12\x1b\n" +
	"\trole_code\x18\x04 \x01(\tR\broleCode\x12+\n" +
	"\x04type\x18\x05 \x01(\x0e2\x17.hub.v1.ContributorTypeR\x04type\x124\n" +
	"\videntifiers\x18\x06 \x03(\v2\x12.hub.v1.IdentifierR\videntifiers\x12 \n" +
	"\vaffiliation\x18\a \x01(\tR\vaffiliation\x12\x1b\n" +
	"\tsource_id\x18\b \x01(\tR\bsourceId\x127\n" +
	"\faffiliations\x18\t \x03(\v2\x13.hub.v1.AffiliationR\faffiliations\"\xbf\x01\n" +
	"\n" +
	"ParsedName\x12\x16\n" +
	"\x06family\x18\x01 \x01(\tR\x06family\x12\x14\n" +
	"\x05given\x18\x02 \x01(\tR\x05given\x12\x16\n" +
	"\x06middle\x18\x03 \x01(\tR\x06middle\x12\x16\n" +
	"\x06suffix\x18\x04 \x01(\tR\x06suffix\x12\x16\n" +
	"\x06prefix\x18\x05 \x01(\tR\x06prefix\x12\x1b\n" +
	"\tfull_name\x18\x06 \x01(\tR\bfullName\x12\x1e\n" +
	"\n" +
	"normalized\x18\a \x01(\tR\n" +
	"normalized\"\x9d\x03\n" +
	"\tDateValue\x12$\n" +
	"\x04type\x18\x01 \x01(\x0e2\x10.hub.v1.DateTypeR\x04type\x12\x10\n" +
	"\x03raw\x18\x02 \x01(\tR\x03raw\x12\x12\n" +
	"\x04year\x18\x03 \x01(\x05R\x04year\x12\x14\n" +
	"\x05month\x18\x04 \x01(\x05R\x05month\x12\x10\n" +
	"\x03day\x18\x05 \x01(\x05R\x03day\x12\x19\n" +
	"\bend_year\x18\x06 \x01(\x05R\aendYear\x12\x1b\n" +
	"\tend_month\x18\a \x01(\x05R\bendMonth\x12\x17\n" +
	"\aend_day\x18\b \x01(\x05R\x06endDay\x123\n" +
	"\tprecision\x18\t \x01(\x0e2\x15.hub.v1.DatePrecisionR\tprecision\x123\n" +
	"\tqualifier\x18\n" +
	" \x01(\x0e2\x15.hub.v1.DateQualifierR\tqualifier\x12\x19\n" +
	"\bis_range\x18\v \x01(\bR\aisRange\x12.\n" +
	"\x04time\x18\f \x01(\v2\x1a.google.protobuf.TimestampR\x04time\x12\x16\n" +
	"\x06season\x18\r \x01(\tR\x06season\"\x8b\x01\n" +
	"\n" +
	"Identifier\x12*\n" +
	"\x04type\x18\x01 \x01(\x0e2\x16.hub.v1.IdentifierTypeR\x04type\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value\x12\x18\n" +
	"\adisplay\x18\x03 \x01(\tR\adisplay\x12!\n" +
	"\fis_preferred\x18\x04 \x01(\bR\visPreferred\"\xb2\x01\n" +
	"\aSubject\x12\x14\n" +
	"\x05value\x18\x01 \x01(\tR\x05value\x129\n" +
	"\n" +
	"vocabulary\x18\x02 \x01(\x0e2\x19.hub.v1.SubjectVocabularyR\n" +
	"vocabulary\x12\x10\n" +
	"\x03uri\x18\x03 \x01(\tR\x03uri\x12\x1b\n" +
	"\tsource_id\x18\x04 \x01(\tR\bsourceId\x12'\n" +
	"\x04type\x18\x05 \x01(\x0e2\x13.hub.v1.SubjectTypeR\x04type\"j\n" +
	"\x06Rights\x12\x1c\n" +
	"\tstatement\x18\x01 \x01(\tR\tstatement\x12\x10\n" +
	"\x03uri\x18\x02 \x01(\tR\x03uri\x12\x18\n" +
	"\alicense\x18\x03 \x01(\tR\alicense\x12\x16\n" +
	"\x06holder\x18\x04 \x01(\tR\x06holder\"y\n" +
	"\fResourceType\x12-\n" +
	"\x04type\x18\x01 \x01(\x0e2\x19.hub.v1.ResourceTypeValueR\x04type\x12\x1a\n" +
	"\boriginal\x18\x02 \x01(\tR\boriginal\x12\x1e\n" +
	"\n" +
	"vocabulary\x18\x03 \x01(\tR\n" +
	"vocabulary\"\x85\x03\n" +
	"\bRelation\x12(\n" +
	"\x04type\x18\x01 \x01(\x0e2\x14.hub.v1.RelationTypeR\x04type\x12!\n" +
	"\ftarget_title\x18\x02 \x01(\tR\vtargetTitle\x12\x1b\n" +
	"\ttarget_id\x18\x03 \x01(\tR\btargetId\x12<\n" +
	"\x0etarget_id_type\x18\x04 \x01(\x0e2\x16.hub.v1.IdentifierTypeR\ftargetIdType\x12\x1d\n" +
	"\n" +
	"target_uri\x18\x05 \x01(\tR\ttargetUri\x12\x1b\n" +
	"\tsource_id\x18\x06 \x01(\tR\bsourceId\x12 \n" +
	"\vdescription\x18\a \x01(\tR\vdescription\x12K\n" +
	"\x14target_resource_type\x18\b \x01(\x0e2\x19.hub.v1.ResourceTypeValueR\x12targetResourceType\x12&\n" +
	"\x0ftarget_type_uri\x18\t \x01(\tR\rtargetTypeUri\"\xb9\x01\n" +
	"\n" +
	"DegreeInfo\x12\x1f\n" +
	"\vdegree_name\x18\x01 \x01(\tR\n" +
	"degreeName\x12!\n" +
	"\fdegree_level\x18\x02 \x01(\tR\vdegreeLevel\x12\x1e\n" +
	"\n" +
	"department\x18\x03 \x01(\tR\n" +
	"department\x12 \n" +
	"\vinstitution\x18\x04 \x01(\tR\vinstitution\x12%\n" +
	"\x04date\x18\x05 \x01(\v2\x11.hub.v1.DateValueR\x04date\"\xc8\x01\n" +
	"\x06Funder\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x1e\n" +
	"\n" +
	"identifier\x18\x02 \x01(\tR\n" +
	"identifier\x12'\n" +
	"\x0fidentifier_type\x18\x03 \x01(\tR\x0eidentifierType\x12#\n" +
	"\raward_numbers\x18\x04 \x03(\tR\fawardNumbers\x12\x1f\n" +
	"\vaward_title\x18\x05 \x01(\tR\n" +
	"awardTitle\x12\x1b\n" +
	"\taward_uri\x18\x06 \x01(\tR\bawardUri\"j\n" +
	"\vAffiliation\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x1e\n" +
	"\n" +
	"identifier\x18\x02 \x01(\tR\n" +
	"identifier\x12'\n" +
	"\x0fidentifier_type\x18\x03 \x01(\tR\x0eidentifierType\"\xa0\x01\n" +
	"\x04File\x12\x12\n" +
	"\x04path\x18\x01 \x01(\tR\x04path\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12\x1b\n" +
	"\tmime_type\x18\x03 \x01(\tR\bmimeType\x12\x1d\n" +
	"\n" +
	"size_bytes\x18\x04 \x01(\x03R\tsizeBytes\x12 \n" +
	"\vdescription\x18\x05 \x01(\tR\vdescription\x12\x12\n" +
	"\x04role\x18\x06 \x01(\tR\x04role\"t\n" +
	"\x10ArchivalLocation\x12\x1e\n" +
	"\n" +
	"collection\x18\x01 \x01(\tR\n" +
	"collection\x12\x16\n" +
	"\x06series\x18\x02 \x01(\tR\x06series\x12\x10\n" +
	"\x03box\x18\x03 \x01(\tR\x03box\x12\x16\n" +
	"\x06folder\x18\x04 \x01(\tR\x06folder\"\x99\x01\n" +
	"\x12PublicationDetails\x12\x14\n" +
	"\x05title\x18\x01 \x01(\tR\x05title\x12\x16\n" +
	"\x06volume\x18\x02 \x01(\tR\x06volume\x12\x14\n" +
	"\x05issue\x18\x03 \x01(\tR\x05issue\x12\x14\n" +
	"\x05pages\x18\x04 \x01(\tR\x05pages\x12\x12\n" +
	"\x04issn\x18\x05 \x01(\tR\x04issn\x12\x15\n" +
	"\x06l_issn\x18\x06 \x01(\tR\x05lIssn\"\x88\x01\n" +
	"\x16HierarchicalGeographic\x12\x18\n" +
	"\acountry\x18\x01 \x01(\tR\acountry\x12\x14\n" +
	"\x05state\x18\x02 \x01(\tR\x05state\x12\x16\n" +
	"\x06county\x18\x03 \x01(\tR\x06county\x12\x12\n" +
	"\x04city\x18\x04 \x01(\tR\x04city\x12\x12\n" +
	"\x04area\x18\x05 \x01(\tR\x04area*\x86\x01\n" +
	"\tGroupType\x12\x1a\n" +
	"\x16GROUP_TYPE_UNSPECIFIED\x10\x00\x12\x14\n" +
	"\x10GROUP_TYPE_ISSUE\x10\x01\x12\x19\n" +
	"\x15GROUP_TYPE_COLLECTION\x10\x02\x12\x15\n" +
	"\x11GROUP_TYPE_SERIES\x10\x03\x12\x15\n" +
	"\x11GROUP_TYPE_VOLUME\x10\x04*s\n" +
	"\x0fContributorType\x12 \n" +
	"\x1cCONTRIBUTOR_TYPE_UNSPECIFIED\x10\x00\x12\x1b\n" +
	"\x17CONTRIBUTOR_TYPE_PERSON\x10\x01\x12!\n" +
	"\x1dCONTRIBUTOR_TYPE_ORGANIZATION\x10\x02*\xd8\x02\n" +
	"\bDateType\x12\x19\n" +
	"\x15DATE_TYPE_UNSPECIFIED\x10\x00\x12\x14\n" +
	"\x10DATE_TYPE_ISSUED\x10\x01\x12\x15\n" +
	"\x11DATE_TYPE_CREATED\x10\x02\x12\x16\n" +
	"\x12DATE_TYPE_CAPTURED\x10\x03\x12\x17\n" +
	"\x13DATE_TYPE_COPYRIGHT\x10\x04\x12\x16\n" +
	"\x12DATE_TYPE_MODIFIED\x10\x05\x12\x17\n" +
	"\x13DATE_TYPE_AVAILABLE\x10\x06\x12\x17\n" +
	"\x13DATE_TYPE_SUBMITTED\x10\a\x12\x16\n" +
	"\x12DATE_TYPE_ACCEPTED\x10\b\x12\x17\n" +
	"\x13DATE_TYPE_PUBLISHED\x10\t\x12\x13\n" +
	"\x0fDATE_TYPE_OTHER\x10\n" +
	"\x12\x13\n" +
	"\x0fDATE_TYPE_VALID\x10\v\x12\x15\n" +
	"\x11DATE_TYPE_UPDATED\x10\f\x12\x17\n" +
	"\x13DATE_TYPE_COLLECTED\x10\r*\xca\x01\n" +
	"\rDatePrecision\x12\x1e\n" +
	"\x1aDATE_PRECISION_UNSPECIFIED\x10\x00\x12\x17\n" +
	"\x13DATE_PRECISION_YEAR\x10\x01\x12\x18\n" +
	"\x14DATE_PRECISION_MONTH\x10\x02\x12\x16\n" +
	"\x12DATE_PRECISION_DAY\x10\x03\x12\x17\n" +
	"\x13DATE_PRECISION_TIME\x10\x04\x12\x19\n" +
	"\x15DATE_PRECISION_DECADE\x10\x05\x12\x1a\n" +
	"\x16DATE_PRECISION_CENTURY\x10\x06*\x86\x01\n" +
	"\rDateQualifier\x12\x1e\n" +
	"\x1aDATE_QUALIFIER_UNSPECIFIED\x10\x00\x12\x1e\n" +
	"\x1aDATE_QUALIFIER_APPROXIMATE\x10\x01\x12\x1c\n" +
	"\x18DATE_QUALIFIER_UNCERTAIN\x10\x02\x12\x17\n" +
	"\x13DATE_QUALIFIER_BOTH\x10\x03*\xe3\x03\n" +
	"\x0eIdentifierType\x12\x1f\n" +
	"\x1bIDENTIFIER_TYPE_UNSPECIFIED\x10\x00\x12\x17\n" +
	"\x13IDENTIFIER_TYPE_DOI\x10\x01\x12\x17\n" +
	"\x13IDENTIFIER_TYPE_URL\x10\x02\x12\x1a\n" +
	"\x16IDENTIFIER_TYPE_HANDLE\x10\x03\x12\x18\n" +
	"\x14IDENTIFIER_TYPE_ISBN\x10\x04\x12\x18\n" +
	"\x14IDENTIFIER_TYPE_ISSN\x10\x05\x12\x19\n" +
	"\x15IDENTIFIER_TYPE_ORCID\x10\x06\x12\x18\n" +
	"\x14IDENTIFIER_TYPE_PMID\x10\a\x12\x19\n" +
	"\x15IDENTIFIER_TYPE_PMCID\x10\b\x12\x19\n" +
	"\x15IDENTIFIER_TYPE_ARXIV\x10\t\x12\x19\n" +
	"\x15IDENTIFIER_TYPE_LOCAL\x10\n" +
	"\x12\x17\n" +
	"\x13IDENTIFIER_TYPE_PID\x10\v\x12\x17\n" +
	"\x13IDENTIFIER_TYPE_NID\x10\f\x12\x18\n" +
	"\x14IDENTIFIER_TYPE_UUID\x10\r\x12\x18\n" +
	"\x14IDENTIFIER_TYPE_ISNI\x10\x0e\x12!\n" +
	"\x1dIDENTIFIER_TYPE_REPORT_NUMBER\x10\x0f\x12\x1f\n" +
	"\x1bIDENTIFIER_TYPE_CALL_NUMBER\x10\x10*\xc2\x01\n" +
	"\vSubjectType\x12\x1c\n" +
	"\x18SUBJECT_TYPE_UNSPECIFIED\x10\x00\x12\x16\n" +
	"\x12SUBJECT_TYPE_TOPIC\x10\x01\x12\x15\n" +
	"\x11SUBJECT_TYPE_NAME\x10\x02\x12\x1b\n" +
	"\x17SUBJECT_TYPE_GEOGRAPHIC\x10\x03\x12\x19\n" +
	"\x15SUBJECT_TYPE_TEMPORAL\x10\x04\x12\x16\n" +
	"\x12SUBJECT_TYPE_GENRE\x10\x05\x12\x16\n" +
	"\x12SUBJECT_TYPE_TITLE\x10\x06*\xf2\x03\n" +
	"\x11SubjectVocabulary\x12\"\n" +
	"\x1eSUBJECT_VOCABULARY_UNSPECIFIED\x10\x00\x12\x1b\n" +
	"\x17SUBJECT_VOCABULARY_LCSH\x10\x01\x12\x1b\n" +
	"\x17SUBJECT_VOCABULARY_MESH\x10\x02\x12\x1a\n" +
	"\x16SUBJECT_VOCABULARY_AAT\x10\x03\x12\x1b\n" +
	"\x17SUBJECT_VOCABULARY_FAST\x10\x04\x12\x1a\n" +
	"\x16SUBJECT_VOCABULARY_DDC\x10\x05\x12\x1a\n" +
	"\x16SUBJECT_VOCABULARY_LCC\x10\x06\x12\x1f\n" +
	"\x1bSUBJECT_VOCABULARY_KEYWORDS\x10\a\x12\x1c\n" +
	"\x18SUBJECT_VOCABULARY_GENRE\x10\b\x12\x1c\n" +
	"\x18SUBJECT_VOCABULARY_LOCAL\x10\t\x12 \n" +
	"\x1cSUBJECT_VOCABULARY_GETTY_TGN\x10\n" +
	"\x12\x1c\n" +
	"\x18SUBJECT_VOCABULARY_LCNAF\x10\v\x12\x1c\n" +
	"\x18SUBJECT_VOCABULARY_ARXIV\x10\f\x12\x1a\n" +
	"\x16SUBJECT_VOCABULARY_MSC\x10\r\x12\x1a\n" +
	"\x16SUBJECT_VOCABULARY_ACM\x10\x0e\x12\x1b\n" +
	"\x17SUBJECT_VOCABULARY_PACS\x10\x0f*\x90\b\n" +
	"\x11ResourceTypeValue\x12\x1d\n" +
	"\x19RESOURCE_TYPE_UNSPECIFIED\x10\x00\x12\x19\n" +
	"\x15RESOURCE_TYPE_ARTICLE\x10\x01\x12\x16\n" +
	"\x12RESOURCE_TYPE_BOOK\x10\x02\x12\x1e\n" +
	"\x1aRESOURCE_TYPE_BOOK_CHAPTER\x10\x03\x12\"\n" +
	"\x1eRESOURCE_TYPE_CONFERENCE_PAPER\x10\x04\x12\x19\n" +
	"\x15RESOURCE_TYPE_DATASET\x10\x05\x12\x1e\n" +
	"\x1aRESOURCE_TYPE_DISSERTATION\x10\x06\x12\x18\n" +
	"\x14RESOURCE_TYPE_THESIS\x10\a\x12\x17\n" +
	"\x13RESOURCE_TYPE_IMAGE\x10\b\x12\x19\n" +
	"\x15RESOURCE_TYPE_JOURNAL\x10\t\x12\x18\n" +
	"\x14RESOURCE_TYPE_REPORT\x10\n" +
	"\x12\"\n" +
	"\x1eRESOURCE_TYPE_TECHNICAL_REPORT\x10\v\x12\x1f\n" +
	"\x1bRESOURCE_TYPE_WORKING_PAPER\x10\f\x12\x1a\n" +
	"\x16RESOURCE_TYPE_PREPRINT\x10\r\x12\x18\n" +
	"\x14RESOURCE_TYPE_POSTER\x10\x0e\x12\x1e\n" +
	"\x1aRESOURCE_TYPE_PRESENTATION\x10\x0f\x12\x1a\n" +
	"\x16RESOURCE_TYPE_SOFTWARE\x10\x10\x12\x17\n" +
	"\x13RESOURCE_TYPE_VIDEO\x10\x11\x12\x17\n" +
	"\x13RESOURCE_TYPE_AUDIO\x10\x12\x12\x15\n" +
	"\x11RESOURCE_TYPE_MAP\x10\x13\x12\x1b\n" +
	"\x17RESOURCE_TYPE_NEWSPAPER\x10\x14\x12#\n" +
	"\x1fRESOURCE_TYPE_NEWSPAPER_ARTICLE\x10\x15\x12\x1c\n" +
	"\x18RESOURCE_TYPE_PERIODICAL\x10\x16\x12\x1c\n" +
	"\x18RESOURCE_TYPE_COLLECTION\x10\x17\x12#\n" +
	"\x1fRESOURCE_TYPE_ARCHIVAL_MATERIAL\x10\x18\x12\x1c\n" +
	"\x18RESOURCE_TYPE_MANUSCRIPT\x10\x19\x12\x18\n" +
	"\x14RESOURCE_TYPE_PATENT\x10\x1a\x12\x1a\n" +
	"\x16RESOURCE_TYPE_STANDARD\x10\x1b\x12\x19\n" +
	"\x15RESOURCE_TYPE_WEBPAGE\x10\x1c\x12\x17\n" +
	"\x13RESOURCE_TYPE_OTHER\x10\x1d\x12\x1d\n" +
	"\x19RESOURCE_TYPE_PEER_REVIEW\x10\x1e\x12\x1d\n" +
	"\x19RESOURCE_TYPE_INTERACTIVE\x10\x1f\x12\x18\n" +
	"\x14RESOURCE_TYPE_OBJECT\x10 \x12'\n" +
	"#RESOURCE_TYPE_CONFERENCE_PROCEEDING\x10!\x12\x16\n" +
	"\x12RESOURCE_TYPE_TEXT\x10\"*\x8d\b\n" +
	"\fRelationType\x12\x1d\n" +
	"\x19RELATION_TYPE_UNSPECIFIED\x10\x00\x12\x1b\n" +
	"\x17RELATION_TYPE_MEMBER_OF\x10\x01\x12\x1c\n" +
	"\x18RELATION_TYPE_HAS_MEMBER\x10\x02\x12\x19\n" +
	"\x15RELATION_TYPE_PART_OF\x10\x03\x12\x1a\n" +
	"\x16RELATION_TYPE_HAS_PART\x10\x04\x12\x1c\n" +
	"\x18RELATION_TYPE_VERSION_OF\x10\x05\x12\x1d\n" +
	"\x19RELATION_TYPE_HAS_VERSION\x10\x06\x12\x1a\n" +
	"\x16RELATION_TYPE_REPLACES\x10\a\x12 \n" +
	"\x1cRELATION_TYPE_IS_REPLACED_BY\x10\b\x12\x1b\n" +
	"\x17RELATION_TYPE_FORMAT_OF\x10\t\x12\x1c\n" +
	"\x18RELATION_TYPE_HAS_FORMAT\x10\n" +
	"\x12\x1c\n" +
	"\x18RELATION_TYPE_REFERENCES\x10\v\x12\x1d\n" +
	"\x19RELATION_TYPE_IS_CITED_BY\x10\f\x12\x17\n" +
	"\x13RELATION_TYPE_CITES\x10\r\x12\x1e\n" +
	"\x1aRELATION_TYPE_DERIVED_FROM\x10\x0e\x12\x1b\n" +
	"\x17RELATION_TYPE_SOURCE_OF\x10\x0f\x12\x1a\n" +
	"\x16RELATION_TYPE_BASED_ON\x10\x10\x12\x1e\n" +
	"\x1aRELATION_TYPE_IS_BASIS_FOR\x10\x11\x12\x1d\n" +
	"\x19RELATION_TYPE_SUPPLEMENTS\x10\x12\x12\"\n" +
	"\x1eRELATION_TYPE_IS_SUPPLEMENT_TO\x10\x13\x12\x1b\n" +
	"\x17RELATION_TYPE_DOCUMENTS\x10\x14\x12\"\n" +
	"\x1eRELATION_TYPE_IS_DOCUMENTED_BY\x10\x15\x12\x1b\n" +
	"\x17RELATION_TYPE_DESCRIBES\x10\x16\x12!\n" +
	"\x1dRELATION_TYPE_IS_DESCRIBED_BY\x10\x17\x12\x1e\n" +
	"\x1aRELATION_TYPE_IDENTICAL_TO\x10\x18\x12\x19\n" +
	"\x15RELATION_TYPE_SAME_AS\x10\x19\x12\x1b\n" +
	"\x17RELATION_TYPE_SERIES_OF\x10\x1a\x12\x1b\n" +
	"\x17RELATION_TYPE_IN_SERIES\x10\x1b\x12\x1c\n" +
	"\x18RELATION_TYPE_RELATED_TO\x10\x1c\x12\x17\n" +
	"\x13RELATION_TYPE_OTHER\x10\x1d\x12!\n" +
	"\x1dRELATION_TYPE_SUPPLEMENTED_BY\x10\x1e\x12\x1d\n" +
	"\x19RELATION_TYPE_REQUIRED_BY\x10\x1f\x12\x1a\n" +
	"\x16RELATION_TYPE_REQUIRES\x10 \x12\x19\n" +
	"\x15RELATION_TYPE_REVIEWS\x10!B\x95\x01\n" +
	"\n" +
	"com.hub.v1B\bHubProtoP\x01ZDgithub.com/lehigh-university-libraries/crosswalk/gen/go/hub/v1;hubv1\xa2\x02\x03HXX\xaa\x02\x06Hub.V1\xca\x02\x06Hub\\V1\xe2\x02\x12Hub\\V1\\GPBMetadata\xea\x02\aHub::V1b\x06proto3"

var (
	file_hub_v1_hub_proto_rawDescOnce sync.Once
	file_hub_v1_hub_proto_rawDescData []byte
)

func file_hub_v1_hub_proto_rawDescGZIP() []byte {
	file_hub_v1_hub_proto_rawDescOnce.Do(func() {
		file_hub_v1_hub_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_hub_v1_hub_proto_rawDesc), len(file_hub_v1_hub_proto_rawDesc)))
	})
	return file_hub_v1_hub_proto_rawDescData
}

var file_hub_v1_hub_proto_enumTypes = make([]protoimpl.EnumInfo, 10)
var file_hub_v1_hub_proto_msgTypes = make([]protoimpl.MessageInfo, 18)
var file_hub_v1_hub_proto_goTypes = []any{
	(GroupType)(0),                 // 0: hub.v1.GroupType
	(ContributorType)(0),           // 1: hub.v1.ContributorType
	(DateType)(0),                  // 2: hub.v1.DateType
	(DatePrecision)(0),             // 3: hub.v1.DatePrecision
	(DateQualifier)(0),             // 4: hub.v1.DateQualifier
	(IdentifierType)(0),            // 5: hub.v1.IdentifierType
	(SubjectType)(0),               // 6: hub.v1.SubjectType
	(SubjectVocabulary)(0),         // 7: hub.v1.SubjectVocabulary
	(ResourceTypeValue)(0),         // 8: hub.v1.ResourceTypeValue
	(RelationType)(0),              // 9: hub.v1.RelationType
	(*Record)(nil),                 // 10: hub.v1.Record
	(*SourceInfo)(nil),             // 11: hub.v1.SourceInfo
	(*Group)(nil),                  // 12: hub.v1.Group
	(*Contributor)(nil),            // 13: hub.v1.Contributor
	(*ParsedName)(nil),             // 14: hub.v1.ParsedName
	(*DateValue)(nil),              // 15: hub.v1.DateValue
	(*Identifier)(nil),             // 16: hub.v1.Identifier
	(*Subject)(nil),                // 17: hub.v1.Subject
	(*Rights)(nil),                 // 18: hub.v1.Rights
	(*ResourceType)(nil),           // 19: hub.v1.ResourceType
	(*Relation)(nil),               // 20: hub.v1.Relation
	(*DegreeInfo)(nil),             // 21: hub.v1.DegreeInfo
	(*Funder)(nil),                 // 22: hub.v1.Funder
	(*Affiliation)(nil),            // 23: hub.v1.Affiliation
	(*File)(nil),                   // 24: hub.v1.File
	(*ArchivalLocation)(nil),       // 25: hub.v1.ArchivalLocation
	(*PublicationDetails)(nil),     // 26: hub.v1.PublicationDetails
	(*HierarchicalGeographic)(nil), // 27: hub.v1.HierarchicalGeographic
	(*structpb.Struct)(nil),        // 28: google.protobuf.Struct
	(*timestamppb.Timestamp)(nil),  // 29: google.protobuf.Timestamp
}
var file_hub_v1_hub_proto_depIdxs = []int32{
	13, // 0: hub.v1.Record.contributors:type_name -> hub.v1.Contributor
	15, // 1: hub.v1.Record.dates:type_name -> hub.v1.DateValue
	19, // 2: hub.v1.Record.resource_type:type_name -> hub.v1.ResourceType
	17, // 3: hub.v1.Record.genres:type_name -> hub.v1.Subject
	17, // 4: hub.v1.Record.subjects:type_name -> hub.v1.Subject
	26, // 5: hub.v1.Record.publication:type_name -> hub.v1.PublicationDetails
	18, // 6: hub.v1.Record.rights:type_name -> hub.v1.Rights
	16, // 7: hub.v1.Record.identifiers:type_name -> hub.v1.Identifier
	25, // 8: hub.v1.Record.archival_location:type_name -> hub.v1.ArchivalLocation
	24, // 9: hub.v1.Record.files:type_name -> hub.v1.File
	17, // 10: hub.v1.Record.physical_form:type_name -> hub.v1.Subject
	20, // 11: hub.v1.Record.relations:type_name -> hub.v1.Relation
	21, // 12: hub.v1.Record.degree_info:type_name -> hub.v1.DegreeInfo
	22, // 13: hub.v1.Record.funders:type_name -> hub.v1.Funder
	27, // 14: hub.v1.Record.geographic:type_name -> hub.v1.HierarchicalGeographic
	28, // 15: hub.v1.Record.extra:type_name -> google.protobuf.Struct
	11, // 16: hub.v1.Record.source_info:type_name -> hub.v1.SourceInfo
	29, // 17: hub.v1.SourceInfo.parsed_at:type_name -> google.protobuf.Timestamp
	0,  // 18: hub.v1.Group.type:type_name -> hub.v1.GroupType
	10, // 19: hub.v1.Group.container:type_name -> hub.v1.Record
	10, // 20: hub.v1.Group.members:type_name -> hub.v1.Record
	14, // 21: hub.v1.Contributor.parsed_name:type_name -> hub.v1.ParsedName
	1,  // 22: hub.v1.Contributor.type:type_name -> hub.v1.ContributorType
	16, // 23: hub.v1.Contributor.identifiers:type_name -> hub.v1.Identifier
	23, // 24: hub.v1.Contributor.affiliations:type_name -> hub.v1.Affiliation
	2,  // 25: hub.v1.DateValue.type:type_name -> hub.v1.DateType
	3,  // 26: hub.v1.DateValue.precision:type_name -> hub.v1.DatePrecision
	4,  // 27: hub.v1.DateValue.qualifier:type_name -> hub.v1.DateQualifier
	29, // 28: hub.v1.DateValue.time:type_name -> google.protobuf.Timestamp
	5,  // 29: hub.v1.Identifier.type:type_name -> hub.v1.IdentifierType
	7,  // 30: hub.v1.Subject.vocabulary:type_name -> hub.v1.SubjectVocabulary
	6,  // 31: hub.v1.Subject.type:type_name -> hub.v1.SubjectType
	8,  // 32: hub.v1.ResourceType.type:type_name -> hub.v1.ResourceTypeValue
	9,  // 33: hub.v1.Relation.type:type_name -> hub.v1.RelationType
	5,  // 34: hub.v1.Relation.target_id_type:type_name -> hub.v1.IdentifierType
	8,  // 35: hub.v1.Relation.target_resource_type:type_name -> hub.v1.ResourceTypeValue
	15, // 36: hub.v1.DegreeInfo.date:type_name -> hub.v1.DateValue
	37, // [37:37] is the sub-list for method output_type
	37, // [37:37] is the sub-list for method input_type
	37, // [37:37] is the sub-list for extension type_name
	37, // [37:37] is the sub-list for extension extendee
	0,  // [0:37] is the sub-list for field type_name
}

func init() { file_hub_v1_hub_proto_init() }
func file_hub_v1_hub_proto_init() {
	if File_hub_v1_hub_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_hub_v1_hub_proto_rawDesc), len(file_hub_v1_hub_proto_rawDesc)),
			NumEnums:      10,
			NumMessages:   18,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_hub_v1_hub_proto_goTypes,
		DependencyIndexes: file_hub_v1_hub_proto_depIdxs,
		EnumInfos:         file_hub_v1_hub_proto_enumTypes,
		MessageInfos:      file_hub_v1_hub_proto_msgTypes,
	}.Build()
	File_hub_v1_hub_proto = out.File
	file_hub_v1_hub_proto_goTypes = nil
	file_hub_v1_hub_proto_depIdxs = nil
}
