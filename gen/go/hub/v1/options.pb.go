// Hub field options for spoke proto definitions.
// These annotations define how spoke fields map to the Hub schema.
//
// Usage in spoke protos:
//
//   import "hub/v1/options.proto";
//
//   message Entry {
//     string title = 1 [(hub.v1.field) = {target: "title"}];
//     repeated Person author = 2 [(hub.v1.field) = {target: "contributors", role: "author"}];
//     string year = 3 [(hub.v1.field) = {target: "dates", date_type: "issued", parser: "year"}];
//     string doi = 4 [(hub.v1.field) = {target: "identifiers", identifier_type: "doi"}];
//   }
//

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        (unknown)
// source: hub/v1/options.proto

package hubv1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	descriptorpb "google.golang.org/protobuf/types/descriptorpb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// FieldOptions defines how a spoke field maps to the Hub schema.
type FieldOptions struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Target Hub field path (e.g., "title", "contributors", "dates", "identifiers", "extra")
	Target string `protobuf:"bytes,1,opt,name=target,proto3" json:"target,omitempty"`
	// For dates: the semantic date type (issued, created, captured, copyright, modified, etc.)
	DateType string `protobuf:"bytes,10,opt,name=date_type,json=dateType,proto3" json:"date_type,omitempty"`
	// For identifiers: the identifier type (doi, url, handle, isbn, issn, orcid, etc.)
	IdentifierType string `protobuf:"bytes,11,opt,name=identifier_type,json=identifierType,proto3" json:"identifier_type,omitempty"`
	// For subjects: the vocabulary (lcsh, mesh, aat, fast, ddc, lcc, keywords, genre, local)
	SubjectVocabulary string `protobuf:"bytes,12,opt,name=subject_vocabulary,json=subjectVocabulary,proto3" json:"subject_vocabulary,omitempty"`
	// For contributors: the default role (author, editor, translator, etc.)
	Role string `protobuf:"bytes,13,opt,name=role,proto3" json:"role,omitempty"`
	// For contributors: the contributor type (person, organization)
	ContributorType string `protobuf:"bytes,14,opt,name=contributor_type,json=contributorType,proto3" json:"contributor_type,omitempty"`
	// For relations: the relation type (member_of, part_of, version_of, references, etc.)
	RelationType string `protobuf:"bytes,15,opt,name=relation_type,json=relationType,proto3" json:"relation_type,omitempty"`
	// For resource types: map to Hub ResourceTypeValue (article, book, thesis, etc.)
	ResourceType string `protobuf:"bytes,16,opt,name=resource_type,json=resourceType,proto3" json:"resource_type,omitempty"`
	// Parser to apply when reading this field
	// Values: passthrough, edtf, iso8601, year, bibtex_name, csl_name, split,
	//
	//	strip_html, normalize_whitespace, doi, isbn, orcid, url, relator, custom
	Parser string `protobuf:"bytes,20,opt,name=parser,proto3" json:"parser,omitempty"`
	// Custom parser name (when parser = "custom")
	CustomParser string `protobuf:"bytes,21,opt,name=custom_parser,json=customParser,proto3" json:"custom_parser,omitempty"`
	// Date format for parsing (e.g., "2006-01-02", "January 2, 2006")
	DateFormat string `protobuf:"bytes,22,opt,name=date_format,json=dateFormat,proto3" json:"date_format,omitempty"`
	// Delimiter for splitting multi-value strings
	Delimiter string `protobuf:"bytes,23,opt,name=delimiter,proto3" json:"delimiter,omitempty"`
	// Validators to apply (comma-separated)
	// Values: required, doi, isbn, issn, orcid, url, email, iso8601, edtf, year_range, pattern, length, range
	Validators string `protobuf:"bytes,30,opt,name=validators,proto3" json:"validators,omitempty"`
	// Regular expression pattern for validation
	Pattern string `protobuf:"bytes,31,opt,name=pattern,proto3" json:"pattern,omitempty"`
	// Minimum length (for strings)
	MinLength int32 `protobuf:"varint,32,opt,name=min_length,json=minLength,proto3" json:"min_length,omitempty"`
	// Maximum length (for strings)
	MaxLength int32 `protobuf:"varint,33,opt,name=max_length,json=maxLength,proto3" json:"max_length,omitempty"`
	// Minimum value (for numbers)
	MinValue int64 `protobuf:"varint,34,opt,name=min_value,json=minValue,proto3" json:"min_value,omitempty"`
	// Maximum value (for numbers)
	MaxValue int64 `protobuf:"varint,35,opt,name=max_value,json=maxValue,proto3" json:"max_value,omitempty"`
	// Minimum number of values required
	MinCount int32 `protobuf:"varint,40,opt,name=min_count,json=minCount,proto3" json:"min_count,omitempty"`
	// Maximum number of values allowed (-1 = unlimited)
	MaxCount int32 `protobuf:"varint,41,opt,name=max_count,json=maxCount,proto3" json:"max_count,omitempty"`
	// Serializer to apply when writing this field
	// Values: passthrough, edtf, iso8601, year, bibtex_name, csl_name, join, custom
	Serializer string `protobuf:"bytes,50,opt,name=serializer,proto3" json:"serializer,omitempty"`
	// Custom serializer name (when serializer = "custom")
	CustomSerializer string `protobuf:"bytes,51,opt,name=custom_serializer,json=customSerializer,proto3" json:"custom_serializer,omitempty"`
	// Join delimiter for serializing arrays
	JoinDelimiter string `protobuf:"bytes,52,opt,name=join_delimiter,json=joinDelimiter,proto3" json:"join_delimiter,omitempty"`
	// XML element name (if different from proto field name)
	XmlName string `protobuf:"bytes,70,opt,name=xml_name,json=xmlName,proto3" json:"xml_name,omitempty"`
	// XML namespace prefix (e.g., "dc", "dcterms", "mods")
	XmlNs string `protobuf:"bytes,71,opt,name=xml_ns,json=xmlNs,proto3" json:"xml_ns,omitempty"`
	// Serialize as XML attribute instead of element
	XmlAttr bool `protobuf:"varint,72,opt,name=xml_attr,json=xmlAttr,proto3" json:"xml_attr,omitempty"`
	// XML character data (no element wrapper, just the value)
	XmlChardata bool `protobuf:"varint,73,opt,name=xml_chardata,json=xmlChardata,proto3" json:"xml_chardata,omitempty"`
	// Omit this field from XML output
	XmlOmit bool `protobuf:"varint,74,opt,name=xml_omit,json=xmlOmit,proto3" json:"xml_omit,omitempty"`
	// RDF predicate this field corresponds to (e.g., "dcterms:title")
	RdfPredicate string `protobuf:"bytes,60,opt,name=rdf_predicate,json=rdfPredicate,proto3" json:"rdf_predicate,omitempty"`
	// Human-readable description
	Description string `protobuf:"bytes,61,opt,name=description,proto3" json:"description,omitempty"`
	// Whether this field should be omitted if empty
	OmitEmpty bool `protobuf:"varint,62,opt,name=omit_empty,json=omitEmpty,proto3" json:"omit_empty,omitempty"`
	// Whether this is a required field
	Required bool `protobuf:"varint,63,opt,name=required,proto3" json:"required,omitempty"`
	// Priority when multiple sources map to same target (higher = preferred)
	Priority      int32 `protobuf:"varint,64,opt,name=priority,proto3" json:"priority,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FieldOptions) Reset() {
	*x = FieldOptions{}
	mi := &file_hub_v1_options_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FieldOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FieldOptions) ProtoMessage() {}

func (x *FieldOptions) ProtoReflect() protoreflect.Message {
	mi := &file_hub_v1_options_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FieldOptions.ProtoReflect.Descriptor instead.
func (*FieldOptions) Descriptor() ([]byte, []int) {
	return file_hub_v1_options_proto_rawDescGZIP(), []int{0}
}

func (x *FieldOptions) GetTarget() string {
	if x != nil {
		return x.Target
	}
	return ""
}

func (x *FieldOptions) GetDateType() string {
	if x != nil {
		return x.DateType
	}
	return ""
}

func (x *FieldOptions) GetIdentifierType() string {
	if x != nil {
		return x.IdentifierType
	}
	return ""
}

func (x *FieldOptions) GetSubjectVocabulary() string {
	if x != nil {
		return x.SubjectVocabulary
	}
	return ""
}

func (x *FieldOptions) GetRole() string {
	if x != nil {
		return x.Role
	}
	return ""
}

func (x *FieldOptions) GetContributorType() string {
	if x != nil {
		return x.ContributorType
	}
	return ""
}

func (x *FieldOptions) GetRelationType() string {
	if x != nil {
		return x.RelationType
	}
	return ""
}

func (x *FieldOptions) GetResourceType() string {
	if x != nil {
		return x.ResourceType
	}
	return ""
}

func (x *FieldOptions) GetParser() string {
	if x != nil {
		return x.Parser
	}
	return ""
}

func (x *FieldOptions) GetCustomParser() string {
	if x != nil {
		return x.CustomParser
	}
	return ""
}

func (x *FieldOptions) GetDateFormat() string {
	if x != nil {
		return x.DateFormat
	}
	return ""
}

func (x *FieldOptions) GetDelimiter() string {
	if x != nil {
		return x.Delimiter
	}
	return ""
}

func (x *FieldOptions) GetValidators() string {
	if x != nil {
		return x.Validators
	}
	return ""
}

func (x *FieldOptions) GetPattern() string {
	if x != nil {
		return x.Pattern
	}
	return ""
}

func (x *FieldOptions) GetMinLength() int32 {
	if x != nil {
		return x.MinLength
	}
	return 0
}

func (x *FieldOptions) GetMaxLength() int32 {
	if x != nil {
		return x.MaxLength
	}
	return 0
}

func (x *FieldOptions) GetMinValue() int64 {
	if x != nil {
		return x.MinValue
	}
	return 0
}

func (x *FieldOptions) GetMaxValue() int64 {
	if x != nil {
		return x.MaxValue
	}
	return 0
}

func (x *FieldOptions) GetMinCount() int32 {
	if x != nil {
		return x.MinCount
	}
	return 0
}

func (x *FieldOptions) GetMaxCount() int32 {
	if x != nil {
		return x.MaxCount
	}
	return 0
}

func (x *FieldOptions) GetSerializer() string {
	if x != nil {
		return x.Serializer
	}
	return ""
}

func (x *FieldOptions) GetCustomSerializer() string {
	if x != nil {
		return x.CustomSerializer
	}
	return ""
}

func (x *FieldOptions) GetJoinDelimiter() string {
	if x != nil {
		return x.JoinDelimiter
	}
	return ""
}

func (x *FieldOptions) GetXmlName() string {
	if x != nil {
		return x.XmlName
	}
	return ""
}

func (x *FieldOptions) GetXmlNs() string {
	if x != nil {
		return x.XmlNs
	}
	return ""
}

func (x *FieldOptions) GetXmlAttr() bool {
	if x != nil {
		return x.XmlAttr
	}
	return false
}

func (x *FieldOptions) GetXmlChardata() bool {
	if x != nil {
		return x.XmlChardata
	}
	return false
}

func (x *FieldOptions) GetXmlOmit() bool {
	if x != nil {
		return x.XmlOmit
	}
	return false
}

func (x *FieldOptions) GetRdfPredicate() string {
	if x != nil {
		return x.RdfPredicate
	}
	return ""
}

func (x *FieldOptions) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *FieldOptions) GetOmitEmpty() bool {
	if x != nil {
		return x.OmitEmpty
	}
	return false
}

func (x *FieldOptions) GetRequired() bool {
	if x != nil {
		return x.Required
	}
	return false
}

func (x *FieldOptions) GetPriority() int32 {
	if x != nil {
		return x.Priority
	}
	return 0
}

// MessageOptions defines message-level Hub mapping options.
type MessageOptions struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The Hub message this spoke message maps to (e.g., "Record", "Contributor")
	Target string `protobuf:"bytes,1,opt,name=target,proto3" json:"target,omitempty"`
	// Whether to preserve unmapped fields in Extra
	PreserveUnmapped bool `protobuf:"varint,2,opt,name=preserve_unmapped,json=preserveUnmapped,proto3" json:"preserve_unmapped,omitempty"`
	// Description of this message's purpose
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// Computed fields that derive values from multiple source fields.
	// These are evaluated after all individual field mappings are processed.
	ComputedFields []*ComputedField `protobuf:"bytes,4,rep,name=computed_fields,json=computedFields,proto3" json:"computed_fields,omitempty"`
	// XML element name for this message type
	XmlName string `protobuf:"bytes,10,opt,name=xml_name,json=xmlName,proto3" json:"xml_name,omitempty"`
	// XML namespaces to declare on this element
	// Format: "prefix=uri" (e.g., "dc=http://purl.org/dc/elements/1.1/")
	XmlNamespaces []string `protobuf:"bytes,11,rep,name=xml_namespaces,json=xmlNamespaces,proto3" json:"xml_namespaces,omitempty"`
	// Default XML namespace URI
	XmlDefaultNs  string `protobuf:"bytes,12,opt,name=xml_default_ns,json=xmlDefaultNs,proto3" json:"xml_default_ns,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MessageOptions) Reset() {
	*x = MessageOptions{}
	mi := &file_hub_v1_options_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MessageOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MessageOptions) ProtoMessage() {}

func (x *MessageOptions) ProtoReflect() protoreflect.Message {
	mi := &file_hub_v1_options_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MessageOptions.ProtoReflect.Descriptor instead.
func (*MessageOptions) Descriptor() ([]byte, []int) {
	return file_hub_v1_options_proto_rawDescGZIP(), []int{1}
}

func (x *MessageOptions) GetTarget() string {
	if x != nil {
		return x.Target
	}
	return ""
}

func (x *MessageOptions) GetPreserveUnmapped() bool {
	if x != nil {
		return x.PreserveUnmapped
	}
	return false
}

func (x *MessageOptions) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *MessageOptions) GetComputedFields() []*ComputedField {
	if x != nil {
		return x.ComputedFields
	}
	return nil
}

func (x *MessageOptions) GetXmlName() string {
	if x != nil {
		return x.XmlName
	}
	return ""
}

func (x *MessageOptions) GetXmlNamespaces() []string {
	if x != nil {
		return x.XmlNamespaces
	}
	return nil
}

func (x *MessageOptions) GetXmlDefaultNs() string {
	if x != nil {
		return x.XmlDefaultNs
	}
	return ""
}

// ComputedField defines a field derived from multiple source fields.
// Used for values that require access to the full source message during parsing.
//
// Example: ProQuest embargo date is computed from embargo_code + accept_date
type ComputedField struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Target Hub field path (e.g., "dates", "extra.embargo_date")
	Target string `protobuf:"bytes,1,opt,name=target,proto3" json:"target,omitempty"`
	// Name of the registered computation function
	// The function must be registered with ComputedFieldRegistry
	Computer string `protobuf:"bytes,2,opt,name=computer,proto3" json:"computer,omitempty"`
	// For dates: the semantic date type (issued, created, available, etc.)
	DateType string `protobuf:"bytes,10,opt,name=date_type,json=dateType,proto3" json:"date_type,omitempty"`
	// For identifiers: the identifier type (doi, url, etc.)
	IdentifierType string `protobuf:"bytes,11,opt,name=identifier_type,json=identifierType,proto3" json:"identifier_type,omitempty"`
	// Description of this computed field
	Description   string `protobuf:"bytes,20,opt,name=description,proto3" json:"description,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ComputedField) Reset() {
	*x = ComputedField{}
	mi := &file_hub_v1_options_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ComputedField) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ComputedField) ProtoMessage() {}

func (x *ComputedField) ProtoReflect() protoreflect.Message {
	mi := &file_hub_v1_options_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ComputedField.ProtoReflect.Descriptor instead.
func (*ComputedField) Descriptor() ([]byte, []int) {
	return file_hub_v1_options_proto_rawDescGZIP(), []int{2}
}

func (x *ComputedField) GetTarget() string {
	if x != nil {
		return x.Target
	}
	return ""
}

func (x *ComputedField) GetComputer() string {
	if x != nil {
		return x.Computer
	}
	return ""
}

func (x *ComputedField) GetDateType() string {
	if x != nil {
		return x.DateType
	}
	return ""
}

func (x *ComputedField) GetIdentifierType() string {
	if x != nil {
		return x.IdentifierType
	}
	return ""
}

func (x *ComputedField) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

// EnumValueOptions for mapping spoke enum values to Hub enum values.
type EnumValueOptions struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The Hub enum value this maps to (e.g., "RESOURCE_TYPE_ARTICLE")
	Target        string `protobuf:"bytes,1,opt,name=target,proto3" json:"target,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EnumValueOptions) Reset() {
	*x = EnumValueOptions{}
	mi := &file_hub_v1_options_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EnumValueOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EnumValueOptions) ProtoMessage() {}

func (x *EnumValueOptions) ProtoReflect() protoreflect.Message {
	mi := &file_hub_v1_options_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EnumValueOptions.ProtoReflect.Descriptor instead.
func (*EnumValueOptions) Descriptor() ([]byte, []int) {
	return file_hub_v1_options_proto_rawDescGZIP(), []int{3}
}

func (x *EnumValueOptions) GetTarget() string {
	if x != nil {
		return x.Target
	}
	return ""
}

var file_hub_v1_options_proto_extTypes = []protoimpl.ExtensionInfo{
	{
		ExtendedType:  (*descriptorpb.FieldOptions)(nil),
		ExtensionType: (*FieldOptions)(nil),
		Field:         50001,
		Name:          "hub.v1.field",
		Tag:           "bytes,50001,opt,name=field",
		Filename:      "hub/v1/options.proto",
	},
	{
		ExtendedType:  (*descriptorpb.MessageOptions)(nil),
		ExtensionType: (*MessageOptions)(nil),
		Field:         50001,
		Name:          "hub.v1.message",
		Tag:           "bytes,50001,opt,name=message",
		Filename:      "hub/v1/options.proto",
	},
	{
		ExtendedType:  (*descriptorpb.EnumValueOptions)(nil),
		ExtensionType: (*EnumValueOptions)(nil),
		Field:         50001,
		Name:          "hub.v1.enum_value",
		Tag:           "bytes,50001,opt,name=enum_value",
		Filename:      "hub/v1/options.proto",
	},
}

// Extension fields to descriptorpb.FieldOptions.
var (
	// optional hub.v1.FieldOptions field = 50001;
	E_Field = &file_hub_v1_options_proto_extTypes[0]
)

// Extension fields to descriptorpb.MessageOptions.
var (
	// optional hub.v1.MessageOptions message = 50001;
	E_Message = &file_hub_v1_options_proto_extTypes[1]
)

// Extension fields to descriptorpb.EnumValueOptions.
var (
	// optional hub.v1.EnumValueOptions enum_value = 50001;
	E_EnumValue = &file_hub_v1_options_proto_extTypes[2]
)

var File_hub_v1_options_proto protoreflect.FileDescriptor

const file_hub_v1_options_proto_rawDesc = "" +
	"\n" +
	"\x14hub/v1/options.proto\x12\x06hub.v1\x1a google/protobuf/descriptor.proto\"\xa9\b\n" +
	"\fFieldOptions\x12\x16\n" +
	"\x06target\x18\x01 \x01(\tR\x06target\x12\x1b\n" +
	"\tdate_type\x18\n" +
	" \x01(\tR\bdateType\x12'\n" +
	"\x0fidentifier_type\x18\v \x01(\tR\x0eidentifierType\x12-\n" +
	"\x12subject_vocabulary\x18\f \x01(\tR\x11subjectVocabulary\x12\x12\n" +
	"\x04role\x18\r \x01(\tR\x04role\x12)\n" +
	"\x10contributor_type\x18\x0e \x01(\tR\x0fcontributorType\x12#\n" +
	"\rrelation_type\x18\x0f \x01(\tR\frelationType\x12#\n" +
	"\rresource_type\x18\x10 \x01(\tR\fresourceType\x12\x16\n" +
	"\x06parser\x18\x14 \x01(\tR\x06parser\x12#\n" +
	"\rcustom_parser\x18\x15 \x01(\tR\fcustomParser\x12\x1f\n" +
	"\vdate_format\x18\x16 \x01(\tR\n" +
	"dateFormat\x12\x1c\n" +
	"\tdelimiter\x18\x17 \x01(\tR\tdelimiter\x12\x1e\n" +
	"\n" +
	"validators\x18\x1e \x01(\tR\n" +
	"validators\x12\x18\n" +
	"\apattern\x18\x1f \x01(\tR\apattern\x12\x1d\n" +
	"\n" +
	"min_length\x18  \x01(\x05R\tminLength\x12\x1d\n" +
	"\n" +
	"max_length\x18! \x01(\x05R\tmaxLength\x12\x1b\n" +
	"\tmin_value\x18\" \x01(\x03R\bminValue\x12\x1b\n" +
	"\tmax_value\x18# \x01(\x03R\bmaxValue\x12\x1b\n" +
	"\tmin_count\x18( \x01(\x05R\bminCount\x12\x1b\n" +
	"\tmax_count\x18) \x01(\x05R\bmaxCount\x12\x1e\n" +
	"\n" +
	"serializer\x182 \x01(\tR\n" +
	"serializer\x12+\n" +
	"\x11custom_serializer\x183 \x01(\tR\x10customSerializer\x12%\n" +
	"\x0ejoin_delimiter\x184 \x01(\tR\rjoinDelimiter\x12\x19\n" +
	"\bxml_name\x18F \x01(\tR\axmlName\x12\x15\n" +
	"\x06xml_ns\x18G \x01(\tR\x05xmlNs\x12\x19\n" +
	"\bxml_attr\x18H \x01(\bR\axmlAttr\x12!\n" +
	"\fxml_chardata\x18I \x01(\bR\vxmlChardata\x12\x19\n" +
	"\bxml_omit\x18J \x01(\bR\axmlOmit\x12#\n" +
	"\rrdf_predicate\x18< \x01(\tR\frdfPredicate\x12 \n" +
	"\vdescription\x18= \x01(\tR\vdescription\x12\x1d\n" +
	"\n" +
	"omit_empty\x18> \x01(\bR\tomitEmpty\x12\x1a\n" +
	"\brequired\x18? \x01(\bR\brequired\x12\x1a\n" +
	"\bpriority\x18@ \x01(\x05R\bpriority\"\x9f\x02\n" +
	"\x0eMessageOptions\x12\x16\n" +
	"\x06target\x18\x01 \x01(\tR\x06target\x12+\n" +
	"\x11preserve_unmapped\x18\x02 \x01(\bR\x10preserveUnmapped\x12 \n" +
	"\vdescription\x18\x03 \x01(\tR\vdescription\x12>\n" +
	"\x0fcomputed_fields\x18\x04 \x03(\v2\x15.hub.v1.ComputedFieldR\x0ecomputedFields\x12\x19\n" +
	"\bxml_name\x18\n" +
	" \x01(\tR\axmlName\x12%\n" +
	"\x0exml_namespaces\x18\v \x03(\tR\rxmlNamespaces\x12$\n" +
	"\x0exml_default_ns\x18\f \x01(\tR\fxmlDefaultNs\"\xab\x01\n" +
	"\rComputedField\x12\x16\n" +
	"\x06target\x18\x01 \x01(\tR\x06target\x12\x1a\n" +
	"\bcomputer\x18\x02 \x01(\tR\bcomputer\x12\x1b\n" +
	"\tdate_type\x18\n" +
	" \x01(\tR\bdateType\x12'\n" +
	"\x0fidentifier_type\x18\v \x01(\tR\x0eidentifierType\x12 \n" +
	"\vdescription\x18\x14 \x01(\tR\vdescription\"*\n" +
	"\x10EnumValueOptions\x12\x16\n" +
	"\x06target\x18\x01 \x01(\tR\x06target:K\n" +
	"\x05field\x12\x1d.google.protobuf.FieldOptions\x18ц\x03 \x01(\v2\x14.hub.v1.FieldOptionsR\x05field:S\n" +
	"\amessage\x12\x1f.google.protobuf.MessageOptions\x18ц\x03 \x01(\v2\x16.hub.v1.MessageOptionsR\amessage:\\\n" +
	"\n" +
	"enum_value\x12!.google.protobuf.EnumValueOptions\x18ц\x03 \x01(\v2\x18.hub.v1.EnumValueOptionsR\tenumValueB\x99\x01\n" +
	"\n" +
	"com.hub.v1B\fOptionsProtoP\x01ZDgithub.com/lehigh-university-libraries/crosswalk/gen/go/hub/v1;hubv1\xa2\x02\x03HXX\xaa\x02\x06Hub.V1\xca\x02\x06Hub\\V1\xe2\x02\x12Hub\\V1\\GPBMetadata\xea\x02\aHub::V1b\x06proto3"

var (
	file_hub_v1_options_proto_rawDescOnce sync.Once
	file_hub_v1_options_proto_rawDescData []byte
)

func file_hub_v1_options_proto_rawDescGZIP() []byte {
	file_hub_v1_options_proto_rawDescOnce.Do(func() {
		file_hub_v1_options_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_hub_v1_options_proto_rawDesc), len(file_hub_v1_options_proto_rawDesc)))
	})
	return file_hub_v1_options_proto_rawDescData
}

var file_hub_v1_options_proto_msgTypes = make([]protoimpl.MessageInfo, 4)
var file_hub_v1_options_proto_goTypes = []any{
	(*FieldOptions)(nil),                  // 0: hub.v1.FieldOptions
	(*MessageOptions)(nil),                // 1: hub.v1.MessageOptions
	(*ComputedField)(nil),                 // 2: hub.v1.ComputedField
	(*EnumValueOptions)(nil),              // 3: hub.v1.EnumValueOptions
	(*descriptorpb.FieldOptions)(nil),     // 4: google.protobuf.FieldOptions
	(*descriptorpb.MessageOptions)(nil),   // 5: google.protobuf.MessageOptions
	(*descriptorpb.EnumValueOptions)(nil), // 6: google.protobuf.EnumValueOptions
}
var file_hub_v1_options_proto_depIdxs = []int32{
	2, // 0: hub.v1.MessageOptions.computed_fields:type_name -> hub.v1.ComputedField
	4, // 1: hub.v1.field:extendee -> google.protobuf.FieldOptions
	5, // 2: hub.v1.message:extendee -> google.protobuf.MessageOptions
	6, // 3: hub.v1.enum_value:extendee -> google.protobuf.EnumValueOptions
	0, // 4: hub.v1.field:type_name -> hub.v1.FieldOptions
	1, // 5: hub.v1.message:type_name -> hub.v1.MessageOptions
	3, // 6: hub.v1.enum_value:type_name -> hub.v1.EnumValueOptions
	7, // [7:7] is the sub-list for method output_type
	7, // [7:7] is the sub-list for method input_type
	4, // [4:7] is the sub-list for extension type_name
	1, // [1:4] is the sub-list for extension extendee
	0, // [0:1] is the sub-list for field type_name
}

func init() { file_hub_v1_options_proto_init() }
func file_hub_v1_options_proto_init() {
	if File_hub_v1_options_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_hub_v1_options_proto_rawDesc), len(file_hub_v1_options_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   4,
			NumExtensions: 3,
			NumServices:   0,
		},
		GoTypes:           file_hub_v1_options_proto_goTypes,
		DependencyIndexes: file_hub_v1_options_proto_depIdxs,
		MessageInfos:      file_hub_v1_options_proto_msgTypes,
		ExtensionInfos:    file_hub_v1_options_proto_extTypes,
	}.Build()
	File_hub_v1_options_proto = out.File
	file_hub_v1_options_proto_goTypes = nil
	file_hub_v1_options_proto_depIdxs = nil
}
